<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="date" content="2016-08-30" />
  <title>Mapping Data Models to VOTable</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../style/ivoa_doc.css" type="text/css" />
  <link rel="stylesheet" href="../style/ivoa-plus.css" type="text/css" />
</head>
<body>
<div><table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0"
  cellpadding="0" width="450"><tr><td><a href="http://www.ivoa.net/"><img
  height="169" alt="IVOA" src="http://www.ivoa.net/icons/IVOA_wb_300.jpg"
  width="300" border="0"/></a></td><td><div style="padding: 3.6pt
  7.2pt;"><p><b><i><span style="font-size: 14pt; color: rgb(0, 90, 156);"><span>
  </span>I</span></i></b><i><span style="font-size: 14pt; color: rgb(0, 90,
  156);">nternational</span></i></p><p><b><i><span style="font-size: 14pt;
  color: rgb(0, 90, 156);"><span>   </span>V</span></i></b><i><span
  style="font-size: 14pt; color: rgb(0, 90,
  156);">irtual</span></i></p><p><b><i><span style="font-size: 14pt; color:
  rgb(0, 90, 156);"><span> </span><span>  </span>O</span></i></b><i><span
  style="font-size: 14pt; color: rgb(0, 90,
  156);">bservatory</span></i></p><p><b><i><span style="font-size: 14pt; color:
  rgb(0, 90, 156);">A</span></i></b><i><span style="font-size: 14pt; color:
  rgb(0, 90, 156);">lliance</span></i><i/></p></div><i/></td></tr></table><br
  xmlns="http://www.w3.org/1999/xhtml"/></div>

<div id="header">
<h1 class="title">Mapping Data Models to VOTable</h1>

<div id="versionstatement">Version 1.0-201506xx</div>
<div id="dateline"><span class="WD" id="docdate">2016-08-30</span></div>

<dl id="docmeta">
<dt>Working Group</dt><dd id="ivoagroup">Data Models</dd>
<dt>This Version</dt><dd><a class="currentlink"
href="http://www.ivoa.net/documents/MappingDMtoVOTable/">
http://www.ivoa.net/documents/MappingDMtoVOTable/</a></dd>
<dt>Latest Version</dt>
<dd><a class="latestlink"
href="http://www.ivoa.net/documents/MappingDMtoVOTable">
http://www.ivoa.net/documents/MappingDMtoVOTable</a></dd>
<dt>Previous Versions</dt>
<dd><ul class="previousversions">
<li class="previousVersion"><a
href="http://www.ivoa.net/documents/xx">
xx</a></li>
</ul></dd>
<dt>Author(s)</dt><dd><ul class="authors">
<li class="author"><a href="http://www.ivoa.net/cgi-bin/twiki/bin/view/IVOA/GerardLemson">
Gerard Lemson</a></li>
<li class="author"><a href="http://www.ivoa.net/cgi-bin/twiki/bin/view/IVOA/OmarLaurino">
Omar Laurino</a></li>
<li class="author">
Patrick Dowler</li>
<li class="author">
Markus Demleitner</li>
<li class="author">
Matthew Graham</li>
<li class="author">
Jesus Salgado</li>
</ul></dd>
<dt>Editor(s)</dt><dd><ul class="editors">
<li class="editor">
Omar Laurino</li>
<li class="editor">
Gerard Lemson</li>
</ul></dd>
</div>

<h2>Contents</h2>
<div id="TOC">
<ul>
<li><a href="#history-of-this-document">History of this document</a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#use-cases"><span class="toc-section-number">2</span> Use Cases</a></li>
<li><a href="#the-need-for-a-mapping-language"><span class="toc-section-number">3</span> The need for a mapping language</a></li>
<li><a href="#mapping-with-the-vodml-element."><span class="toc-section-number">4</span> Mapping with the <code>VODML</code> element.</a><ul>
<li><a href="#complextype-vodmlannotation"><span class="toc-section-number">4.1</span> complexType: VODMLAnnotation</a></li>
<li><a href="#simpletype-vodmlreference"><span class="toc-section-number">4.2</span> simpleType: VODMLReference</a><ul>
<li><a href="#version-1"><span class="toc-section-number">4.2.1</span> Version 1:</a></li>
<li><a href="#version-2"><span class="toc-section-number">4.2.2</span> Version 2</a></li>
</ul></li>
<li><a href="#the-vo-dml-preamble"><span class="toc-section-number">4.3</span> The VO-DML preamble</a></li>
<li><a href="#special-annotations-from-the-vo-dml-mapping-model"><span class="toc-section-number">4.4</span> Special annotations from the VO-DML Mapping model</a></li>
</ul></li>
<li><a href="#general-information-about-this-spec"><span class="toc-section-number">5</span> General information about this spec</a><ul>
<li><a href="#sample-model-and-instances"><span class="toc-section-number">5.1</span> Sample model and instances</a></li>
<li><a href="#data-carriers-in-votable"><span class="toc-section-number">5.2</span> Data carriers in VOTable</a></li>
<li><a href="#single-table-representations-and-object-relational-mapping"><span class="toc-section-number">5.3</span> Single-table representations and Object-Relational Mapping</a></li>
</ul></li>
<li><a href="#patterns-for-annotating-votable-normative"><span class="toc-section-number">6</span> Patterns for annotating VOTable [NORMATIVE]</a><ul>
<li><a href="#model"><span class="toc-section-number">6.1</span> Model</a><ul>
<li><a href="#model-declaration-group-in-votable"><span class="toc-section-number">6.1.1</span> Model declaration: GROUP in VOTABLE</a></li>
</ul></li>
<li><a href="#objecttype"><span class="toc-section-number">6.2</span> ObjectType</a><ul>
<li><a href="#singleton-root-objecttype-direct-group"><span class="toc-section-number">6.2.1</span> Singleton root ObjectType: direct GROUP</a></li>
<li><a href="#root-objecttype-instances-in-table-i-not-identified"><span class="toc-section-number">6.2.2</span> Root ObjectType instances in Table I: not identified</a></li>
<li><a href="#root-objecttype-instances-in-table-ii-identified"><span class="toc-section-number">6.2.3</span> Root ObjectType instances in Table II: identified</a></li>
</ul></li>
<li><a href="#datatype"><span class="toc-section-number">6.3</span> DataType</a><ul>
<li><a href="#root-datatype-as-singleton-direct-group"><span class="toc-section-number">6.3.1</span> Root DataType as singleton: direct GROUP</a></li>
<li><a href="#root-datatype-values-in-table-records-indirect-group"><span class="toc-section-number">6.3.2</span> Root DataType values in TABLE records: indirect GROUP</a></li>
<li><a href="#datatype-as-attribute-group-in-group"><span class="toc-section-number">6.3.3</span> DataType as Attribute: GROUP in GROUP</a></li>
</ul></li>
<li><a href="#primitivetype-and-enumeration"><span class="toc-section-number">6.4</span> PrimitiveType and Enumeration</a><ul>
<li><a href="#singleton-primitive-value-as-param"><span class="toc-section-number">6.4.1</span> Singleton primitive value as PARAM</a></li>
<li><a href="#enumliteral-as-option"><span class="toc-section-number">6.4.2</span> EnumLiteral as OPTION</a></li>
<li><a href="#skosconcept-as-option"><span class="toc-section-number">6.4.3</span> SKOSConcept as OPTION</a></li>
</ul></li>
<li><a href="#attributes"><span class="toc-section-number">6.5</span> Attributes</a><ul>
<li><a href="#attribute-values-in-field-fieldref-in-group-in-table"><span class="toc-section-number">6.5.1</span> Attribute values in FIELD: FIELDref in GROUP in TABLE</a></li>
<li><a href="#attribute-to-param-in-group"><span class="toc-section-number">6.5.2</span> Attribute to PARAM in GROUP</a></li>
<li><a href="#attribute-to-paramref-in-group"><span class="toc-section-number">6.5.3</span> Attribute to PARAMref in GROUP</a></li>
<li><a href="#datatype-as-attribute-groupref-in-group"><span class="toc-section-number">6.5.4</span> DataType as Attribute: “GROUPref” in GROUP</a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">6.6</span> References</a><ul>
<li><a href="#reference-to-singleton-object-in-direct-group"><span class="toc-section-number">6.6.1</span> Reference to singleton Object in direct GROUP</a></li>
<li><a href="#reference-to-objects-in-a-table-i-objects-in-same-row"><span class="toc-section-number">6.6.2</span> Reference to object(s) in a TABLE I: objects in same row</a></li>
<li><a href="#reference-to-objects-in-a-table-ii-objects-in-different-rows-possibly-different-table"><span class="toc-section-number">6.6.3</span> Reference to object(s) in a TABLE II: objects in different rows, possibly different TABLE</a></li>
<li><a href="#reference-to-object-in-external-data-store"><span class="toc-section-number">6.6.4</span> Reference to Object in external data store</a></li>
</ul></li>
<li><a href="#composition"><span class="toc-section-number">6.7</span> Composition</a><ul>
<li><a href="#composition-i-child-group-inside-parent-group"><span class="toc-section-number">6.7.1</span> Composition I: child GROUP inside parent GROUP</a></li>
<li><a href="#composition-ii-object-relational-reference-from-child-to-parent-both-in-tables"><span class="toc-section-number">6.7.2</span> Composition II: object-relational reference from child to parent, both in TABLEs</a></li>
</ul></li>
<li><a href="#extends-inheritance-todo-needs-work"><span class="toc-section-number">6.8</span> Extends, inheritance (<strong>TODO</strong> needs work!)</a></li>
<li><a href="#value-unit-ucd"><span class="toc-section-number">6.9</span> Value, Unit, UCD</a></li>
</ul></li>
<li><a href="#notable-absences"><span class="toc-section-number">7</span> Notable absences</a><ul>
<li><a href="#atomic-types-support-for-custom-and-legacy-utypes"><span class="toc-section-number">7.1</span> Atomic Types: support for custom and legacy UTYPEs</a></li>
<li><a href="#packages"><span class="toc-section-number">7.2</span> Packages</a></li>
<li><a href="#objecttype-to-table"><span class="toc-section-number">7.3</span> ObjectType to TABLE</a></li>
<li><a href="#attribute-to-fieldparam-in-table"><span class="toc-section-number">7.4</span> Attribute to FIELD|PARAM in TABLE</a></li>
</ul></li>
<li><a href="#serializing-to-other-file-formats"><span class="toc-section-number">8</span> Serializing to other file formats</a></li>
</ul>
</div>

<h2>Abstract</h2>
<p class="abstract">
<p>Data providers and curators provide a great deal of metadata with their data files: this metadata is invaluable for users and for Virtual Observatory software developers. In order to be interoperable, the metadata must refer to common Data Models. This specification defines a scheme for annotating VOTable instances in a standard, consistent, interoperable fashion, so that each piece of metadata can unambiguously refer to the correct Data Model element it expresses, assuming there is a suitable data model. With this specification, data providers can unambiguously and completely represent Data Model instances in the VOTable format, and clients can build <em>faithful</em> representations of such instances. The mapping is operated through opaque, portable strings. These used to be called <code>utypes</code>, but document uses a new annotation mechanism. This proposal assumes agreement on a VOTable extension that adds an explicit mapping element <code>&lt;VODML&gt;</code> to selected VOTable elements (<code>GROUP</code>, <code>PARAM</code>, <code>PARAMref</code>, <code>FIELDref</code>) and which indicates that those elements are representing particular elements from some VO-DML model.</p>
</p>

<div>
<h2>Status of this document</h2>
<p id="status" class="WD">A list of current IVOA Recommendations and other
 technical documents can be found at <a
 href='http://www.ivoa.net/Documents/'>http://www.ivoa.net/Documents/</a>.</p>
</div>

<h2 id="history-of-this-document" class="unnumbered">History of this document</h2>
<p><strong>TODO</strong> migrate document's history</p>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Data providers put a lot of effort in organizing and maintaining metadata that precisely describes their data files. This information is invaluable for users and for software developers that provide users with user-friendly VO-enabled applications. For example, such metadata can characterize the different axes of the reference system in which the data is expressed, or the history of a measurement, like the publication where the measurement was drawn from, the calibration type, and so forth. In order to be interoperable, this metadata must refer to some Data Model that is known to all parties: the IVOA defines and maintains such standardized Data Models that describe astronomical data in an abstract, interoperable way.</p>
<p>In order to enable such interoperable, extensible, portable annotation of data files, one needs:</p>
<ul>
<li><p>A language to unambiguously and efficiently describe Data Models and their elements’ identificators (VO-DML, <span class="citation">(Lemson <a href="#ref-vodml">2015</a>)</span>).</p></li>
<li><p>Pointers linking a specific piece of information (data or metadata) to the Data Model element it represents<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p></li>
<li><p>A mapping specification that unambiguously describes the mapping strategies that lead to faithful representations of Data Model instances in a specific format.</p></li>
</ul>
<p>Without a consistent language for describing Data Models there can be no interoperability, both between them, reuse of models by models, or in their use in other specifications. Such a language must be expressive and formal enough to enable the serialization of data types of growing complexity and the development of reusable, extensible software components and libraries that can make the technological uptake of the VO standards seamless and scalable.</p>
<p>For serializations to non-standard representations one needs to map the abstract Data Model to a particular format meta-model. For instance, the VOTable format defines <code>RESOURCE</code>s, <code>TABLE</code>s, <code>PARAM</code>s, <code>FIELD</code>s, and so forth, and provides explicit attributes such as <code>units</code>, <code>UCD</code>s, and <code>utypes</code>: in order to represent instances of a Data Model, one needs to define an unambiguous mapping between these meta-model elements and the Data Model language, so to make it possible for software to be able to parse a file according to its Data Model and to Data Providers to mark up their data products.</p>
<p>While one might argue that a standard for portable, interoperable Data Model representation would have been required before one could think about such a mapping, we are specifying it only at a later stage. In particular several different interpretations of <code>UTYPE</code>s have been proposed and used<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. This specification aims to resolve this ambiguity.</p>
<p>Any standard trying to reconcile these very different usages must take them into account and make the transition from the current usages to the new standard as seamless as possible. For this reason, this document also shows how the current <code>UTYPE</code>s usages can be seamlessly integrated with the new scheme, so to minimize the transition effort.</p>
<p>As a matter of fact, existing files and services can be made compliant according to this specification by simply <em>adding</em> annotations and keeping the old ones. So they do not need to <em>change</em> them in such a way that would necessarily make them incompatible with existing software.</p>
<p>Several sections of this document are utterly informative: in particular, the appendices provide more information about the impact of this specification to the current and future IVOA practices.</p>
<p>This specification describes how to represent Data Model instances using the VOTable schema. This representation uses the <code>&lt;VODML&gt;</code>; element introduced for this purpose in VOTable v1.4 <span class="citation">(<span class="citeproc-not-found" data-reference-id="votable"><strong>???</strong></span>)</span> and the structure of the VOTable meta-model elements to indicate how instances of data models are stored in VOTable documents. We show many examples and give a complete listing of allowed mapping patterns.</p>
<p>In sections 1-6 we give an introduction to why and how the VODML elements can be used to hold pointers into the data models and several examples that illustrate the mapping.</p>
<p>Section 6.7.3 is a rigorous listing of all valid annotations, and the normative part of the specification. Section 8 describes what patterns and usages this specification does <em>not</em> cover; moreover, it describes how legacy and custom <code>@utype</code>s can be treated in this specification’s framework: as such, this section actually describes the <em>transition</em> from the current usages and this specification. Section 9 described ideas how this specification might be used for annotating other tabular formats, and how to generalize it to other, more structured data serialization formats. Section 10 contains references.</p>
<p>The appendices contain additional material. Appendix A describes the VODML annotation element that was added to the VOTable schema to support this mapping specification. Appendix B describes different types of client software and how they could deal with VOTables annotated according to the current specification. Appendix C defines a set-based “language” for expressing mapping patterns in a more formal manner. Appendix D tries to answer some frequently asked questions.</p>
<p><strong>TODO</strong> section numbers in paragraphs above and below.</p>
<p><strong>Throughout the document we will refer to some real or example Data Models. Please remember that such models have been designed to be fairly simple, yet complex enough to illustrate all the possible constructs that this specification covers. They are not to be intended as actual DMs, nor, by any means, this specification suggests their adoption by the IVOA or by users and or Data Providers. In some cases we refer to actual DMs in order to provide an idea of how this specification relates to real life cases involving actual DMs.</strong></p>
<h1 id="use-cases"><span class="header-section-number">2</span> Use Cases</h1>
<p>The use cases enabled by this mapping definition are limitless. This bold statement can be easily validated by considering that what we describe is analogous to the natural mapping between Data Models and XSD schemata, where instances are expressed in XML documents. XML is widely used in so many ways that it is impossible to list them all. As a matter of fact, XML can even express lists of its own use cases.</p>
<p>However, to give a sense of what it is possible to accomplish with this specification, we provide some explicit use cases relative to the VO domain.</p>
<p><strong>Find a value representing a specific concept.</strong> Given a VOTable annotated with VODML concepts, a client can extract a piece of information by finding a <code>PARAM</code> or <code>FIELDref</code> annotated with a predefined <code>VODML/ROLE</code> or <code>VODML/TYPE</code>. For example, the client can find the luminosity measurement(s) in a file by looking for the <code>GROUP</code> element containing a VODML/TYPE with value <code>src:source.LuminosityMeasurement</code>.</p>
<p><strong>Serialize and de-serialize instances according to a data model.</strong> Using this specification (or software implementing it), a data provider can serialize the metadata for a dataset according to a data model. A client can build in memory a faithful representation of that instance according to the data provider’s annotations, assuming the knowledge of a finite set of <code>VODMLREF</code>s. For example, the client can find all the information about a Source by looking at a <code>GROUP</code> annotated with the <code>UTYPE</code> <code>src:source.Source</code>, and interpret its components (<code>PARAM</code>s and <code>FIELDref</code>s) as the attributes of the object, identified by their <code>UTYPE</code> strings.</p>
<p><strong>Model-unaware serialization and de-serialization.</strong> Model-unaware readers and writers can serialize and de-serialize instances according to specific data models by mapping the contents of a VOTable to model description files. This may include file browsing, code generation, data integration, etc.</p>
<p><strong>VO-enabled plotting and fitting applications.</strong> An application whose main requirement is to display, plot, and/or fit data cannot be required to be aware of <em>all</em> data models. However, if these data models share some common representation of quantities, their errors, and their units, the application can discover these pieces of information and structure a plot, or perform a fit, with minimal user input: each point will be associated with an error bar, upper/lower limits, and other metadata. The application remains mostly Data Model-agnostic: it wouldn’t need to <em>understand</em> high-level concepts like Spectrum, or Photometry.</p>
<p><strong>Validators.</strong> The existence of an explicit Data Model representation language and of a precise, unambiguous mapping specification using <code>UTYPE</code>s enables the creation of universal validators, just as it happens for XML and XSD: the validator can parse the Data Model descriptions imported by the VOTable and check that the file represents valid instances of the Data Model.</p>
<p><strong>VO Publishing Helper.</strong> A universal publisher application may help data providers in interactively mapping Data Models elements to their files or DB tables, either producing a VOTable template with the appropriate UTYPEs annotation, or by creating a DAL service on the fly. The VO Publisher application is not required to be DM-aware, since it can get all the information from the standardized description files.</p>
<p><strong>VO Importer.</strong> Users and Data Providers may have non-compliant files that they want to convert to a VO-compliant format according to some data model: a DM-unaware Importer application may allow them to do so for any standard Data Model.</p>
<p><strong>Extensibility.</strong> Most often each astronomical facility, instrument, or mission needs to express measurements and metadata attributes that are unique to the facility, instrument, or mission. A data provider may want to <em>extend</em> a Data Model, adding to the common information about astronomical sources and data products the metadata that is specific for their instruments or domain. The added metadata can be serialized in a standardized fashion so that the user can take advantage of the information.</p>
<h1 id="the-need-for-a-mapping-language"><span class="header-section-number">3</span> The need for a mapping language</h1>
<p>When encountering a data container, i.e. a file or database containing data, one may wish to interpret its contents according to some external, predefined data model. That is, one may want to try to identify and extract instances of the data model from amongst the information. For example in the “global as view” approach to information integration, one identifies elements (e.g. tables) defined in a global schema with views defined on the distributed databases<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>If one is told that the data container is structured according to some standard serialization format of the data model, one is done. I.e. if the local database is an exact <em>implementation</em> of the global schema, one needs no special annotation mechanism to identify these instances. An example of this is an XML document conforming to an XML schema that is an exact physical <em>representation</em> of the data model. We call such representations <em>faithful</em>.</p>
<p>But in an information integration project like the IVOA, which aims to homogenize access to many distributed heterogeneous data sets, databases and documents are in general <em>not</em> structured according to a standard representation of some predefined, global data model. The best one may hope for is to obtain an <em>interpretation</em> of the data set, defining it as a <em>custom serialization</em> of the result of a <em>transformation</em> of the global data model<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. For example, even if databases themselves are exact replications of a global data model, results of general queries will be such custom serializations.</p>
<p>To interpret such a custom serialization one generally needs extra information that can provide a <em>mapping</em> of the serialization to the original model. If the serialization <em>format</em> is known, this mapping may be given in phrases containing elements both from the serialization format and the data model. For example if our serialization contains data stored in ‘rows’ in one or more ‘tables’ that each have a unique ‘name’ and contain ‘columns’ also with a ‘name’, you might be able to say things like:</p>
<ul>
<li><p>The rows in this table named SOURCE contain <em>instances</em> of <em>object type</em> ‘Source’ as defined in <em>data model</em> ‘SourceDM’ <strong>(SourceDM is an example model formally defined later in this document)</strong>.</p></li>
<li><p>The <em>type</em>’s ‘name’ <em>attribute</em> (having <em>datatype</em> ‘string’, a <em>primitive type</em>) also acts as the <em>identifier</em> of the Source <em>instances</em> and is stored in the single column with name ID.</p></li>
<li><p>The <em>type’s</em> ‘classification’ <em>attribute</em> is stored in the table column CLASSIFICATION (from the <em>data model</em> we know its <em>datatype</em> is an <em>enumeration</em> with certain <em>values</em>, e.g. ‘star’, ‘galaxy’, ‘agn’).</p></li>
<li><p>The <em>type’s</em> ‘position’ <em>attribute</em> (being of <em>structured data type</em> ‘SkyCoordinate’ defined in <em>model</em> ‘SourceDM’) is stored over the two columns RA and DEC, where RA stores the SkyCoordinate’s <em>attribute</em> ‘longitude’, DEC stores the ‘latitude‘ <em>attribute</em>. Both must be interpreted using an <em>instance</em> of the SkyCoordinateSystem <em>type</em>, This <em>instance</em> is stored in 1) another document elsewhere, referenced by a <em>reference</em> to a URI, or 2) in this document, by means of an <em>identifier.</em></p></li>
<li><p><em>Instances</em> from the <em>collection</em> of luminosities of the Source <em>instances</em> are stored in the same row as the source itself. Columns MAG_U and ERR_U give the ‘magnitude’ and ‘error’ <em>attributes</em> of <em>type</em> LuminosityMeasurement in the “u band”, an <em>instance</em> of the Filter <em>type</em>. (stored elsewhere in this document (‘a <em>reference</em> to this Filter instance is ...’). Columns MAG_G and ERR_G ... etc.</p></li>
<li><p>Luminosity <em>instances</em> also have a filter <em>relation</em> that points to instances of the PhotometryFilter <em>structured data type</em>, defined in the IVOA PhotDM model, whose <em>package</em> is imported by the SourceDM.</p></li>
</ul>
<p>In this example the <em>underlined</em> words refer to concepts defined in VO-DML, a meta-model that is used as a formal language for expressing data models. The use of such a modeling language lies in the fact that it provides formal, simple and implementation neutral definitions of the possible structure, the ‘type’ and ‘role’ of the elements from the actual data models that one may encounter in the serialization (SourceDM). This can be used to constrain or validate the serialization, but more importantly it allows us to formulate mapping rules between the serialization format (itself a kind of meta-model) and the meta-model, independent of the particular data models used; for example rules like:</p>
<ul>
<li><p>An <em>object type</em> MUST be stored in a ‘group’.</p></li>
<li><p>A ‘<em>primitive type</em>’ MUST be stored in a ‘column’.</p></li>
<li><p>A <em>reference</em> MUST identify an <em>object type</em> <em>instance</em> represented elsewhere, either in another ‘table’, possibly in the same table, possibly in another document.</p></li>
<li><p>An <em>attribute</em> SHOULD be stored in the same table as its containing <em>object type</em>.</p></li>
<li><p>etc</p></li>
</ul>
<p>Clearly free-form English sentences as the ones in the example are not what we’re after. If we want to be able to identify how a data model is represented in some custom serialization we need a formal, computer readable mapping language.</p>
<p>One part of the mapping language should be anchored in a formally defined serialization language. After all, for some tool to interpret a serialization, it MUST understand its format. A completely freeform serialization is not under consideration here. This document assumes VOTable, even though a discussion on other formats is provided in Section 9.</p>
<p>The mapping language must support the interpretation of elements from the serialization language in terms of elements from the data model. If we want to define a generic mapping mechanism, one by which we can describe how a general data model is serialized inside a VOTable, it is necessary to use a general data model <em>language</em> as the target for the mapping, such as the one described above. This language can give formal and more explicit meaning to data modeling concepts, possibly independent of specific languages representation languages such as XML schema, Java or the relational model.</p>
<p>This document uses VO-DML as the target language.</p>
<p>The final ingredient in the mapping language is a mechanism that ties the components from the two different meta-models together into &quot;sentences&quot;. This generally requires some kind of explicit annotation, some meta-data elements that provide an identification of source to target structure. This document uses an extension to VOTable with a VODML element which can provide this link in a rather simple manner.</p>
<ul>
<li><p>It contains two elements, TYPE and ROLE, the value of which must correspond to the VODML-ID identifier of an element explicitly defined in VO-DML/XML.</p></li>
<li><p>The VOTable element owning the VODML element is said to <em>represent</em> the identified VO-DML data model element. It identifies one or more instances of the data model element, the identification depends on the kind of element and on the context in which it appears.</p></li>
<li><p>There is a set of rules that constrain <em>which</em> VOTable elements can be identified with <em>which</em> type of VO-DML element and how the context plays a role here.</p></li>
</ul>
<blockquote>
<p>This solution is sufficient and it is in some sense the simplest and most explicit approach for annotating a VOTable. It may <em>not</em> be the most natural or suitable approach for other meta-models such as FITS or TAP_SCHEMA. For example the current approach relies heavily using on GROUPs to identify most of the structural mapping. FITS and TAP_SCHEMA do not currently possess such a construct. We will discuss this at the end of this document.</p>
</blockquote>
<h1 id="mapping-with-the-vodml-element."><span class="header-section-number">4</span> Mapping with the <code>VODML</code> element.</h1>
<p>Here we discuss the technicalities of <em>how</em> to annotate VOTable with VO-DML metadata. The later sections will provide details on the implied semantics of these annotations and rules on their application.</p>
<p>VOTable 1.2 introduced the <code>@utype</code> attribute, which was intended to represent &quot;pointers into a data model&quot;. A precise and formal definition on how this “pointing” was to be achieved and a description of its meaning was missing though.</p>
<p><strong>TODO</strong> Missing Votable reference</p>
<p>First, a formal definition of the target of the pointers was missing. To solve this, data models were usually accompanied by a list of “utypes” (<strong>TODO</strong> [TBD refer to STC, Characterization, Spectrum]), and these could be used as values for said <code>@utype</code>, be it in VOTable or for example in the Table Access Protocol metadata. These were not linked in any formal, machine readable way to the underlying data model.</p>
<p>Basically it means that the data model is represented solely by a list of attributes, which does not do justice to the complexity of data models describing complex data products like Data Cubes or the provenance of Simulations. These contain complex object hierarchies organized in graphs with various types of relations between individual objects. It also proved difficult to express the relationship among different, but overlapping, data models, with much discussion centred on the question how to reuse utypes from one model in the definition of another.</p>
<p>The approach is basically not much more than another vocabulary, similar to UCDs <span class="citation">(<span class="citeproc-not-found" data-reference-id="ucd"><strong>???</strong></span>)</span>, or SKOS vocabularies <span class="citation">(<span class="citeproc-not-found" data-reference-id="skos"><strong>???</strong></span>)</span>, obtained by different means. Efforts were made to provide some structure to these values that might provide some hints of their location in a model, but there was no formal mechanism on how to derive that structure and it was unclear whether it could truly represent the richness of the existing and future data models. In particular there was no standard defined how this could be achieved and no common usage patterns were discovered <span class="citation">(Graham <a href="#ref-usages">2013</a>)</span>.</p>
<p>As described above (<strong>TODO</strong> TBD check, true?) VO-DML has solved the problem that there was no formal target for these pointers in the data model itself and formally defines how models can be reused in the definition of other, dependent models. Precisely <em>how</em> to use these pointers in a VOTable to provide a complete annotation useful for interoperability requires more work though. It requires restrictions on which VOTable elements can point to which concepts and how they are organized.</p>
<p>The current specification provides such a definition. It shows how data publishers can identify also the more complex data model elements such as structured types and relationships inside some published data source, be it a VOTable or relational database published through the TAP protocol. It notes that in fact the meta-model defined by the VOTable schema is perfectly suited for supporting such a <em>mapping</em> in an almost 1-1 and completely logical fashion.</p>
<p>This specification defines various <em>mapping patterns</em> from VOTable to VO-DML. Such a pattern identifies a VOTable element with a VO-DML element. The VO-DML element is said to be <em>represented</em> by the VOTable element. The mapping pattern indicates that instances of identified VO-DML types are present in the VOTable. These may be atomic <em>values</em> (instances of VO-DML ValueTypes <span class="citation">(Lemson <a href="#ref-vodml">2015</a>)</span>), represented by <code>PARAM@value</code> or by cells in a table column identified by a FIELDref. Alternatively they may be instances of structured types (<strong>TODO</strong> ref to location of VO-DML doc) represented by GROUPS consisting of multiple PARAMs, PARAMrefs, or FIELDrefs. Especially this use of the GROUP element, introduced already in version 1.10 of the VOTable specification, that distinguishes this approach from the previous ones. The GROUP element can be directly mapped to the structured types defied in VO-DM and by mapping its components to corresponding components in the VO-DML type definition a 1-1 mapping is achieved almost trivially<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. The complete set of mapping patterns supported by this specification will be defined formally in section 6.7.3 (<strong>TODO</strong> fix reference).</p>
<p>In the rest of this chapter we discuss <em>how</em> the VOTable elements are to identify the corresponding VO-DML element. Originally it was assumed that the <code>@utype</code> attribute of these VOTable elements (PARAM, PARAMref, FIELDref and GROUP) would be used to identify which data model element is represented. But it was decided <em>not</em> to use <code>@utype</code> after all<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. Instead it was agreed that the VOTable schema would be extended with a new type elements, <code>&lt;VODML&gt;</code> to be added to these VOTable elements. This element would take the task that was originally intended for <code>@utype</code>, namely to point into a data model. The requirement of extending the VOTable schema is unfortunate and the existing schema would have sufficed to represent the mapping patterns<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>, on the other hand it allows us to design a much more explicit annotation mechanism than would be possible when using <code>@utype</code>-s only.</p>
<p>The extension to the VOTable schema is reproduced in Appendix A. (<strong>TODO</strong> fix reference) In the next few sub-sections we discuss this element in detail.</p>
<p><strong>TODO</strong> TBD see if we need next paragraphs here or in other parts of text</p>
<p>A typical usage scenario may be a VOTable naïve (see Appendix B) client that is sensitive to certain models only, say STC. Such a tool can be written to understand annotation with STC types. Finding an element mapped to a type definition from STC it might infer for example that it represents a coordinate on the sky and use this information according to its requirements.</p>
<p>Such a tool would not necessarily understand other models where such an STC type is <em>used</em> as a role. So, if the annotation refers to both the attribute’s role <em>and</em> type, even a naïve client can trivially find the information it needs. A more advanced client may want to read the Data Model Description File that describes the Data Model in a standardized, machine readable, fashion.</p>
<p>Other scenarios involve inheritance and polymorphism. Inheritance allows models to extend classes defined in other data models. Polymorphism is the common object-oriented design concept that says that the declared type of a property may not be the same as the type of an instance of that property that is actually serialized. In particular, the value of a property may be an instance of a <em>subtype</em> of the declared type. So in general it is not enough to know the declared datatype type of the attribute (for example) to uniquely know which type of instance to expect. And it may also not be possible to infer the instance type uniquely from the contents of the element representing the attribute. Hence only annotating with the VO-DML <strong>Role</strong> may not be sufficient to infer all DM information about a VOTable element. Hence we include the possibility to annotate VOTable elements with the exact VO-DML <strong>Type</strong> as well.</p>
<p>Typed languages such as Java support a casting operation, which provides more information to the interpreter about the type it may expect a certain instance to be.</p>
<h2 id="complextype-vodmlannotation"><span class="header-section-number">4.1</span> complexType: VODMLAnnotation</h2>
<p>According to the schema fragment in Appendix A, the VODML element consists of elements <code>&lt;TYPE&gt;</code>, <code>&lt;ROLE&gt;</code>; and possibly one or more <code>&lt;OPTION&gt;</code> elements. We ignore the latter element here, see the detailed definition in section 6.7.3 for their use. Note, at least one of TYPE or ROLE must be present.</p>
<p>A VODML/TYPE element MUST have as value a valid <strong>vodmlref</strong> (see next subsection) ,which formally indicates that the VOTable element it belongs to represents an instance of the identified VO-DML <strong>Type</strong>. The VO-DML/XML document that the <strong>vodmlref</strong> identifies through its prefix will give the formal definition of that type at the element identified by the suffix <strong>vodml-id</strong>.</p>
<p>Most instances of types are actually used in the definition of a larger, structured type: they play a role in its definition [TBD ref to location in VO-DML element]. In VOTable this structured parent type will be represented by a GROUP (see 7.2 or 7.2). A VOTable element that is contained in such a group MUST identify which precise role it represents through the VODML/ROLE element. This element is again a vodmlref that MUST identify a <strong>Role</strong> (i.e. <strong>Attribute</strong>, <strong>Reference</strong> or <strong>Composition</strong> relation) available on the <strong>Type</strong> identified by the parent GROUP.</p>
<p>These elements VODML/TYPE and VODML/ROLE</p>
<h2 id="simpletype-vodmlreference"><span class="header-section-number">4.2</span> simpleType: VODMLReference</h2>
<p>This type represents a reference to a single element in a VO-DML/XML document. It take over the role of the <code>@utype</code> attribute in this regards. Whenever we wish to refer to instances of the VODMLReference type we will call them <strong>vodmlref</strong>-s. A vodmlref is a string with the following syntax:</p>
<p><strong>vodmlref ::= prefix ‘:’ vodml-id.</strong></p>
<p>The prefix identifies the model in which the element identified by the suffix is defined.</p>
<p>How this is to be done is still under some discussion and we describe both versions next. (<strong>TODO</strong> TBD version 1 is the currently accepted approach; needs rewrite once we settle on one of these)</p>
<p><strong>vodml-ids</strong> are always considered opaque, meaning that clients have no reason to parse them. They are identifiers mapping VOTable elements to VO-DML elements in the identified data model. Thus, they must follow the same syntax rules defined in the VO-DML/Schema document.</p>
<p>The following two sections describe two different scenarios for the UTYPEs format: they both have pros and cons, and we need more discussion and feedback from the community in order to adopt only one of the two.</p>
<h3 id="version-1"><span class="header-section-number">4.2.1</span> Version 1:</h3>
<p>Prefixes MUST be exactly the same as the <strong>name</strong> attribute of the model in the VO-DML/XML document that defines it. They are sequences of [A-Za-z0-9_-], and they are case sensitive.</p>
<p>For new models, that are not (yet) standardized or for custom data models used in a smaller community, It is recommended to form DM prefixes as <code>&lt;author-acronym&gt;_&lt;dm-name&gt;</code>, where the <code>&lt;dm-name&gt;</code> is the name of a standard data model; thus, NED's derivation of spec could have <code>ned_spec</code> as a prefix, CDS's derivation <code>cds_spec</code>.</p>
<p>Prefixes correspond to major versions for the corresponding data models. Thus, <strong>vodmlrefs</strong> remain constant over &quot;compatible&quot; changes in the sense of <span class="citation">(Lemson <a href="#ref-vodml">2015</a>)</span>.  In consequence, clients must assume a compatible extension when encountering an unknown <strong>vodmlref</strong> with a known prefix (and should in general not fail).</p>
<p>Another consequence of this rule is that there may be several VO-DML URLs for a given prefix.  To identify a data model, use the prefix, not the VO-DML URL, which is intended for retrieval of the data model definition exclusively.  In case a client requires the exact minor version of the data model, it must inspect the GROUPs identifying which models are used in a VOTable as described in section 7.1 below.</p>
<h3 id="version-2"><span class="header-section-number">4.2.2</span> Version 2</h3>
<p>Prefixes are sequences of [A-Za-z0-9_-], and they are case sensitive.</p>
<h4 id="the-namespace-uri"><span class="header-section-number">4.2.2.1</span> The Namespace URI</h4>
<p>The <strong>vodmlref</strong> prefix is a reference to a namespace URI defined in a VO-DML preamble (see 4.3, also 7.1).</p>
<p>The namespace URI MUST be an IVOA Resource Name (IVORN) in the form ivo://authorityID/DM-ID</p>
<h4 id="how-to-look-for-a-vodmlref-in-a-document"><span class="header-section-number">4.2.2.2</span> How to look for a vodmlref in a document</h4>
<p>Clients may match <strong>vdmlrefs</strong> by the simple string comparison of the <code>&lt;ROLE&amp;&gt;</code> or <code>&lt;TYPE&gt;</code> elementsin a VOTable with <strong>vodml-ids</strong> defined in the Data Models descriptions.</p>
<p>Clients need to look for the Data Models they are interested in by parsing the VO-DML preamble (see 4.3) and matching the Model’s URI with the ones declared in the preamble. The preamble maps the Model to a prefix string. This string must be attached to the id part according to the <strong>prefix:vodml-id</strong> syntax before it can be compared to the <strong>vdmlrefs</strong> in the document.</p>
<h4 id="extended-notation-for-portable-use-vdmlrefs-as-uris"><span class="header-section-number">4.2.2.3</span> Extended notation for portable use: vdmlrefs as URIs</h4>
<p>In order to make <strong>vdmlrefs</strong> portable outside of the VOTable semantics, we define an extended URI notation for <strong>vdmlrefs</strong> by stringing together the namespace URI and the local name of their QName compact notation: the <strong>vodml-id</strong> will be the fragment part of the URI.</p>
<p>Thus, the extended notation for a <strong>vdmlref</strong> with <strong>vodml-id</strong> ‘Foo.bar’ will be:</p>
<p>ivo://authorityID/DM-ID#Foo.bar</p>
<p>Such IDs can be referenced in any context and can be resolved to the VO-DML document description using the standard mechanism for resolving IVORNs in Resource Registries.</p>
<h2 id="the-vo-dml-preamble"><span class="header-section-number">4.3</span> The VO-DML preamble</h2>
<p>This section assumes Alternative 1 in section 4.2</p>
<p>In order to signal to the reader that a VOTable document falls under this specification, a VOTable instance MUST declare all the Data Models it includes, their versions, and the <strong>vodmlref</strong> prefixes for this model. They MUST also declare the actual URL of the VO-DML/XML description as a shortcut<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<p>Any number of such declarations can be included in a document.</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>vo-dml:Model<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;name&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span><span class="ot"> value=</span><span class="st">&quot;src&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.name<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;version&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span><span class="ot"> value=</span><span class="st">&quot;1.0&quot;</span> <span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.version<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;url&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span>
<span class="ot">      value=</span><span class="st">&quot;https://volute.googlecode.com/svn/trunk/projects/dm/vo-dml/models/sample/Source.vo-dml.xml&quot;</span> <span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.url<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
<span class="kw">&lt;/GROUP&gt;</span></code></pre></td></tr></table></div>
<p>The above example introduces the Source Data Model and declares the name “src” which is to be used as prefix to <strong>vodmlref</strong>-s pointing to its elementsIt also identifies the url referring to the VO-DML/XML description of the Data Model. Notice the “vo-dml:Model” special VODML/TYPE that annotates the GROUP element to introduce the declaration. No role should be used here.</p>
<p>The preamble GROUPs MUST be direct children of the VOTABLE element.</p>
<p>Note that the VO-DML preamble MUST include the models corresponding to ALL the different prefixes used for the <strong>vodmlrefs</strong> in the VOTable. As a matter of fact, the preamble can be seen as a way to declare such prefixes and map them to models. Note furthermore that the <strong>vo-dml</strong> prefix used in the above annotations itself refers to an explicitly defined data model. It will be described in the next section.</p>
<h2 id="special-annotations-from-the-vo-dml-mapping-model"><span class="header-section-number">4.4</span> Special annotations from the VO-DML Mapping model</h2>
<p>There are some special <strong>vodmlrefs</strong> with prefix <em>vo-dml</em> (<strong>TODO</strong> TBD should we use different name? E.g. vodml-i or so? To identify this models deals with mapping instances?). These can be used to create specialized mapping patterns. We have already encountered some examples in the previous section to identify Models represented in a VOTable.</p>
<p>We actuall use the same mapping patterns defined in this specification for this. This implies we need a special data model, which we name <em>VO-DML Instance Mapping</em> and whose prefix is <em>vo-dml</em> (<strong>TODO</strong> should maybe change this to <em>vodml-i</em>). The model can be found <a href="https://volute.googlecode.com/svn/trunk/projects/dm/vo-dml/models/vo-dml/VO-DML.vo-dml.xml">here</a><a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>.</p>
<h1 id="general-information-about-this-spec"><span class="header-section-number">5</span> General information about this spec</h1>
<h2 id="sample-model-and-instances"><span class="header-section-number">5.1</span> Sample model and instances</h2>
<p>For examples we use a highly simplified version of a possible Source data model, illustrated by its UML representation in Figure 1.</p>
<div class="figure">
<img src="media/image3.png" alt="Figure 1 Data model used in examples. It represents a simplified Source data model, containing luminosities that refer to the imported PhotDM. It also defines a simplistic version of an STC model with some types for defining coordinates on the sky, for the sake of simplicity and just for example purposes." />
<p class="caption">Figure 1 Data model used in examples. It represents a simplified Source data model, containing luminosities that refer to the imported PhotDM. It also defines a simplistic version of an STC model with some types for defining coordinates on the sky, for the sake of simplicity and just for example purposes.</p>
</div>
<p>The model defines some types allowing one to define a Source with position on the sky and a collection of luminosities. The position is modeled as a DataType, ‘SkyCoordinate’. SkyCoordinate has a reference to a coordinate frame that is required to interpret its longitude and latitude attributes. The luminosities are really <em>measurements</em> of luminosities in a given filter that is indicated by a reference to a PhotometryFilter, which is imported from the PhotometryDM; hence they have a value <em>and</em> an error. A Quantity DataType is introduced that provides a real value and a unit.</p>
<p>The models are <em>by no means</em> meant to be comprehensive and include some admittedly artificial elements such as an Equinox PrimitiveType, which is supposed to be a simple string and might carry enough semantic value of its own to use it as an annotation on PARAM elements for example.</p>
<p>Note that this sample model defines a Package that contains all the types. This package shows up in the values of the <strong>vodml-ids</strong> we use to identify the different elements. The values we use for these <strong>vodml-id</strong> identifiers are generated from the VO-DML using a particular grammar: they are path-like expressions that are guaranteed to be unique and give some indication of the location of the element they point to in the data model.</p>
<p>We also use some sample instances of the models. These are here illustrated by UML instance diagrams. The diagram in Figure 2 represents the first two lines returned from a query<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> to the SDSS DR7 database.</p>
<p>[Figure 2 Instance diagram representing SDSS objetcs as sources in the sample data model. The first few results are represented from the default radial SDSS query at <a href="http://skyserver.sdss.org/dr7/en/tools/search/radial.asp" class="uri">http://skyserver.sdss.org/dr7/en/tools/search/radial.asp</a>] (media/sdss_instance.jpg)</p>
<h2 id="data-carriers-in-votable"><span class="header-section-number">5.2</span> Data carriers in VOTable</h2>
<p>VO-DML describes four different kinds of types: PrimitiveType (PT), Enumeration (E), DataType (DT) and ObjectType (OT). PT, E and DT are value types; OT is an object - or reference type. PT and E are atomic, their values consist of a single value; DT and OT are structured, they are built from multiple values, organized as attributes, and possibly of reference relations to OTs. An OT can also have composition relations, or collections of other OTs, and can have an identifier, an attribute of undetermined type that is implicitly defined for ObjectTypes.</p>
<p>To store instances (<em>values</em> and <em>objects</em>) of these types in a VOTable various options are available. Atomic values (i.e. instances of PT and E) are stored in cells in a row in a table (i.e. a TD) or in the value attribute of a PARAM (<code>@value</code>). To store an instance of a structured type one must store its components. To identify the structured instance in a serialization one must be able to identify the individual components and how they are to be combined. This aggregation is done using a GROUP element. It is the main representation of structured types, both ObjectType and DataType. It is also used to represent relations to object types. These may be stored using foreign-key-like mechanisms or through some kind of hierarchy.</p>
<p>In fact in the approach described here virtually <em>all</em> mapping of VOTable to VO-DML is performed by GROUP elements and their components. The VODML elements contained in them identifies which elements are to be combined to create the object or DataType instance, what the roles are that these components play (attribute, reference).</p>
<h2 id="single-table-representations-and-object-relational-mapping"><span class="header-section-number">5.3</span> Single-table representations and Object-Relational Mapping</h2>
<p>Broadly speaking, this specification is all about Object-Relational Mapping (ORM). Data Models are represented in VO-DML according to an Object Oriented paradigm, although in a very limited fashion that is also suited for use in Relational Databases.</p>
<p>(<strong>TODO</strong> OL: Actually, I think it's not OOP, rather it's Entity-Relationship, which is also what's stated below.)</p>
<p>As VOTable can represent several tables in the same file with rich metadata, one can look at VOTable as a database that can represent complex relational models.</p>
<p>Such models are usually defined in terms of entities, with each table representing each entity, and relationships that can be expressed as tables themselves or as constraints on the values in the tables, and most often with a combination of tables and constraints. For instance, a Many-To-Many relationship between two Entities is usually represented in the relational model as a table holding IDs of instances from the tables representing the Entities, with Foreign Keys constraints.</p>
<p>Astronomers mainly work with single tables that hold flattened representations of relatively simple models, although in some cases complex data models are serialized in several tables inside the same file.</p>
<p>This specification covers both requirements. Serializations of simple models in a flattened table are easier to achieve than complex ORM mappings where information is normalized into different tables, but they are both achievable in VOTable. Moreover, the hybrid case of partly de-normalized representations, where the model is only partly normalized, is more challenging but should also be addressable in terms of this specification.</p>
<p>In any case, the examples in section 6, and most of section 6.7.3 (the normative part of this document) are focused on the single-table, flattened representations of instances according to some data model. Some of the patterns described in these sections are also applicable to simple ORM cases. Especially the sections dealing with mapping reference and composition relations also deal with the more complex cases of proper ORM mappings, where data is partly or completely normalized into different tables.</p>
<p>The simple and complex ORM patterns described by this specification usually belong to very different concrete use cases, so it should be acceptable in a broad range of cases that implementers, both on the server and on the client side, focus on the single-table mappings. Data providers requiring more complex patterns, more advanced applications, or applications built on top of standard software libraries that implement this specification as a whole will need to take advantage of the ORM mapping patterns.</p>
<h1 id="patterns-for-annotating-votable-normative"><span class="header-section-number">6</span> Patterns for annotating VOTable [NORMATIVE]</h1>
<p>In this section we list all legal mapping patterns that can be used to express how instances of VO-DML-defined types are represented in a VOTable and the possible roles they play. It defines which VOTable elements can be annotated with <code>&lt;VODML&gt;</code> elements described in section 4, what restrictions there are and how to interpret the annotation.</p>
<p>The organization of the following sections is based on the different VO-DML concepts that can be represented. Each of these subsections contains sub-subsections which represent the different possible ways the concept may be encountered in a VOTable and discuss rules and constraints on those annotations. We start with <strong>Model</strong>, and then we discuss value types (<strong>PrimitiveType</strong>, <strong>Enumeration</strong> and <strong>DataType</strong>) and <strong>Attributes</strong>. Then <strong>ObjectType</strong> and the relationships, <strong>Composition</strong> (collection), <strong>Reference</strong> and <strong>Inheritance</strong> (extends). <strong>Package</strong> is not mapped: none of the use cases required this element to be actually mapped to a VOTable instance.</p>
<p>Each subsection contains a concise, formal description of a mapping pattern, according to a simple “grammar” described in Appendix C. (<strong>TODO</strong> TBC)</p>
<p>For example the pattern expression</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G| G <span class="math inline"> ∈ </span> TABLE &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; G/VODML/ROLE = NULL}</td>
</tr>
</tbody>
</table>
<p>Defines the pattern: GROUP directly under a TABLE, with VODML/TYPE element identifying an <strong>ObjectType</strong> and without VODML/ROLE element.</p>
<p>For example <code>GROUP|VODML/TYPE=”vo-dml:Model”] $\Rightarrow$ Model</code> implies the GROUP with VODML/TYE set to <em>vo-dml:Model</em> is mapped to a Model.</p>
<p>See whether we should define a list of all the legal mapping patterns in an Appendix.</p>
<p>Some comments on how we refer to VOTable and VO-DML elements (<strong>TODO</strong> TBD redundant with text above in section ...)</p>
<ul>
<li><p>When referring to VOTable elements we will use the notation by which these elements will occur in VOTable documents, i.e. in general “all caps”, E.g. GROUP, FIELD, (though FIELDref).</p></li>
<li><p>When referring to rows in a TABLE element in a VOTable, we will use TR, when referring to individual cells, TD. Even though such elements only appear in the TABLEDATA serialization of a TABLE. When referring to a column in the TABLE we will use FIELD, also if we do not intend the actual FIELD element annotating the column.</p></li>
<li><p>When referring to an XML attribute on a VOTable element we will prefix it with a ‘@’, e.g. <code>@id</code>, <code>@ref</code>.</p></li>
<li><p>References to VO-DML elements will be capitalized and in <strong>courier bold</strong>, using their VO-DML/XSD type definitions. E.g. ObjectType, Attribute.</p></li>
<li><p>Some mapping solutions require a reference to a GROUP defined elsewhere in the same VOTable. We refer to such a construct as a “GROUPref”, which is not an element of the current VOTable standard (v1.3). It refers to a GROUP with a <code>@ref</code> attribute, which must <em>always</em> identify another GROUP in the same document. The target GROUP must have an <code>@id</code> attribute. In cases where this is important we will indicate that this combination is to be interpreted as a “GROUPref”, including the quotes.</p></li>
</ul>
<p>The following list defines some shorthand phrases (underlined), which we use in the descriptions below:</p>
<ul>
<li><p>Generally when using the phrase <em>meta-type</em> we mean a &quot;kind of&quot; type as defined in VO-DML. These are <strong>PrimitiveType</strong>, <strong>Enumeration</strong>, <strong>DataType</strong> and <strong>ObjectType</strong>.</p></li>
<li><p>With <em>atomic type</em> we will mean a <strong>PrimitiveType</strong> or an <strong>Enumeration</strong> as defined in VO-DML.</p></li>
<li><p>A <em>structured type</em> will refer to an <strong>ObjectType</strong> or <strong>DataType</strong> as defined in VO-DML.</p></li>
<li><p>With a property <em>available on</em> or <em>defined on</em> a (structured) type we will mean an Attribute or Reference, or (in the case of ObjectTypes) a Collection defined on that type itself, or inherited from one of its base class ancestors.</p></li>
<li><p>A VO-DML <strong>Type</strong> <em>plays a role</em> in the definition of another (structured) type if the former is the declared data type of a property available on the latter.</p></li>
<li><p>When writing that a VOTable element <em>represents</em> a certain VO-DML type, we mean that the VOTable element is mapped through its <code>&lt;VODML&gt;</code> annotation either directly to the type, or that it identifies a role played by the type in another type’s definition.</p></li>
<li><p>A <em>descendant</em> of a VOTable element is an element contained in that element, or in a descendant of that element. This is a standard recursive definition and can go up the hierarchy as well: an <em>ancestor</em> of an element is the direct container of that element, or an ancestor of that container.</p></li>
</ul>
<p><strong>Regarding the <em>normative</em> aspects of this specification</strong></p>
<p>When we say this section is NORMATIVE we mean that:</p>
<ol style="list-style-type: decimal">
<li>when a client finds an annotation pattern conforming to one defined here, that client is justified in interpreting it as described in the comments for that pattern. It is an ANNOTATION ERROR if that were to lead to inconsistencies<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>.</li>
<li>when a client encounters a pattern not in this list, the client SHOULD ignore it. Interpreting it as a mapping to a data model MAY work, but is not mandated and other clients need not conform to this.</li>
</ol>
<h2 id="model"><span class="header-section-number">6.1</span> Model</h2>
<h3 id="model-declaration-group-in-votable"><span class="header-section-number">6.1.1</span> Model declaration: GROUP in VOTABLE</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G| G <span class="math inline"><em>i</em><em>n</em></span> VOTABLE &amp; G/VODML/TYPE=”<em>vo-dml:Model</em>”}</td>
</tr>
</tbody>
</table>
<p>A GROUP element with VODML element identifying a Model and placed directly under the root VOTABLE element indicates that the corresponding VO-DML model is used in VODML associations.</p>
<p><strong>Restrictions</strong></p>
<ul>
<li>GROUP element representing a VO-DML Model must exist directly under VOTABLE</li>
<li>Each such GROUP MUST have a VODML element with VODML/TYPE=”vo-dml:Model”, <em>no</em> VODML/ROLE</li>
<li>MUST have child PARAM element with VODML/ROLE=”vo-dml:Model.uri” and <code>@value</code> the URI of the VO-DML document representing the model. <code>@name</code> is irrelevant, <code>@datatype=”char”</code> and <code>@arraysize=”*”</code>. This annotation allows clients to <em>discover</em> whether a particular model is used in the document, the prefix of its <code>@utype</code> in the document, and to resolve the Model to its VO-DML description. The URI MUST be a IVORN registered in the VO registries.</li>
<li>SHOULD have child PARAM element with VODML/ROLE=”vo-dml:Model.url” and <code>@value</code> the url of the VO-DML document representing the model. <code>@name</code> is irrelevant, <code>@datatype=”char”</code> and <code>arraysize=”*”</code>. This is a convenient shortcut for the resolution of the URI. Data providers should make sure the URL is not broken. Clients should make sure that they fall back to resolving the URI if the URL is broken.</li>
<li>MUST have child PARAM element with VODML/ROLE=”vo-dml:Model.name” and <code>@value</code> the name of the Model, which also works as the <strong>vodmlref</strong> prefix (see Section 4). <code>@name</code> is irrelevant, <code>@datatype=”char”</code> and <code>arraysize=”\*”</code>.</li>
</ul>
<p><strong>Example</strong></p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>vo-dml:Model<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;name&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span><span class="ot"> value=</span><span class="st">&quot;src&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.name<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;version&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span><span class="ot"> value=</span><span class="st">&quot;1.0&quot;</span> <span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.version<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;url&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span>
<span class="ot">      value=</span><span class="st">&quot;https://volute.googlecode.com/svn/trunk/projects/dm/vo-dml/models/sample/Source.vo-dml.xml&quot;</span> <span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:Model.url<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>  
<span class="kw">&lt;/GROUP&gt;</span></code></pre></td></tr></table></div>
<h2 id="objecttype"><span class="header-section-number">6.2</span> ObjectType</h2>
<p>See also section 7.7 on composition for more patterns regarding serialisation of <strong>ObjectType</strong> instances.</p>
<h3 id="singleton-root-objecttype-direct-group"><span class="header-section-number">6.2.1</span> Singleton root ObjectType: direct GROUP</h3>
<p><strong>Pattern expression</strong>:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G | G <span class="math inline"><em>s</em><em>u</em><em>b</em><em>s</em><em>e</em><em>t</em></span> RESOURCE &amp; G <span class="math inline"> ⊄ </span> TABLE &amp; G <span class="math inline"> ⊄ </span> GROUP[VODML] &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; G/VODML/ROLE = NULL}</td>
</tr>
</tbody>
</table>
<p>Singleton <strong>ObjctType</strong> represented by “direct GROUP”. Not in a TABLE, in a RESOURCE. MUST have VODML/TYPE, and no VODML/ROLE</p>
<p>Notice that there is a formal difference in VO-DML between DataType and ObjectType. From a practical point of view, these differences can be summarized as follows:</p>
<ul>
<li><p>DataType does not inherit the vo-dml:ObjectType.ID attribute</p></li>
<li><p>You cannot Reference a DataType instance</p></li>
<li><p>You cannot have a Collection of DataType instances</p></li>
</ul>
<h3 id="root-objecttype-instances-in-table-i-not-identified"><span class="header-section-number">6.2.2</span> Root ObjectType instances in Table I: not identified</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G | G <span class="math inline"> ⊂ </span> TABLE &amp; G <span class="math inline"> ⊄ </span> GROUP[VODML] &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; G/VODML/ROLE = NULL}</td>
</tr>
</tbody>
</table>
<h3 id="root-objecttype-instances-in-table-ii-identified"><span class="header-section-number">6.2.3</span> Root ObjectType instances in Table II: identified</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G, GROUP I, FIELDref F | I <span class="math inline"> ∈ </span> G &amp; G <span class="math inline"> ⊂ </span> TABLE &amp; G <span class="math inline"> ⊄ </span> GROUP[VODML] &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; G/VODML/ROLE = NULL &amp; I/VODML/ROLE = “<em>vo-dml:ObjectTypeInstance.ID</em>” &amp; F <span class="math inline"> ∈ </span> I &amp; F/VODML/ROLE = “<em>vodml:Identifier.field</em>”}</td>
</tr>
</tbody>
</table>
<p>When the VOTable document stores the result of an ADQL query it may be common to find multiple copies of the same <strong>ObjectType</strong> instance represented in a table. [TBD example of query joining parent to child replicating parent information.] If one wants to indicate this is the case one MUST use an Identifier pattern. Here one maps one or more columns to fields in the <em>vo-dml:ObjectTypeInstance.ID</em> property that every <strong>ObjectType</strong> instance inherits form its implicit super-type, <em>vo-dml:ObjectTypeInstance</em>. TBC</p>
<p>This same identifier also allows the creation of Object-Relational Mapping patterns for references, this is described in section 7.6.3.</p>
<p>If such an explicitidentifier mapping does not exist, as is the case in 7.2.27.3.2, there is formally no way for clients to infer that instances in different rows are the same, even if all their properties have the same value. After all, <strong>ObjectTypes</strong> are <em>not</em> identified by the values of their properties, but <em>only</em> by an identifier (**TODO* TBD ref to VO-DML definition).</p>
<p><strong>Restrictions/conditions/rules</strong>:</p>
<ul>
<li>Clients SHOULD consider it an error if they encounter two objects with identical IDs, that otherwise have distinct values for the same properties.</li>
</ul>
<h2 id="datatype"><span class="header-section-number">6.3</span> DataType</h2>
<p>A DataType instance (also a <em>value</em>) is structured; it consists of values assigned to each of its attributes and possibly references. To represent the complete instance of a DataType the various attributes (and references) must be grouped together; in VOTable this is done using a GROUP element. GROUPs in fact can play two different roles, depending on where the instance’s data is really stored. If all values are eventually stored exclusively in PARAMs in the GROUP, or possibly outside the GROUP but accessed through PARAMrefs, the GROUP <em>directly</em> represents a complete instance.</p>
<p>If even only one of the attributes is stored in a FIELD and accessed through a FIELDref, the GROUP <em>indirectly</em> represents possibly multiple instances, one for each TR. This is also true in any child GROUP containing a FIELDref and so on. We will use these terms, <em>direct</em> and <em>indirect</em> representation all through the document. And note that this same classification holds for ObjectTypes discussed in 7.2, though with a twist related to possible child GROUPs representing Collections.</p>
<p>The attribute values of a DataType are stored according to the prescription for storing instances of their data type. For attributes with declared data type a PrimitiveType or Enumeration section provides details. If the attribute’s data type is itself a DataType the prescription in the current section should be used recursively. DataTypes can also have References to ObjectTypes, but a discussion of how to store References is deferred to section 7.4, after the discussion of storing ObjectType instances, which is provided in section 7.2.</p>
<h3 id="root-datatype-as-singleton-direct-group"><span class="header-section-number">6.3.1</span> Root DataType as singleton: direct GROUP</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G | G <span class="math inline"> ⊂ </span> RESOURCE &amp; G <span class="math inline"> ⊄ </span> TABLE &amp; G <span class="math inline"> ⊄ </span> GROUP[VODML]&amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>DataType</strong> &amp; G/VODML/ROLE = NULL}</td>
</tr>
</tbody>
</table>
<ul>
<li>Singleton <strong>DataType</strong> value, represented by “direct GROUP”. Not in a TABLE, in a RESOURCE. MUST have VODML/TYPE, and MUST NOT have VODML/ROLE.</li>
</ul>
<p>Restrictions:</p>
<ul>
<li>A GROUP in a RESOURCE cannot have FIELDrefs, only PARAMs, PARAMrefs and GROUPs. The GROUP represents therefore a single instance of the DataType directly as defined in 8.2, with the PARAMs etc. providing the values of the components of the DataType.</li>
</ul>
<p>Comments:</p>
<p>The possible role this instance plays in the VOTable document must have been defined outside of any mapping to a data model. After all, in contrast to instances of ObjectTypes, the existence of instances of value types need not be explicitly stated (see the description of value types in [1]). An example could be a VOTable containing the result of a simple cone search. A RESOURCE in that document might contain a GROUP representing the position of the cone, which may be mapped through its <code>@utype</code> to a DataType “src:source.SkyCoordinate” (if such a type existed: our sample model contains a type like it).</p>
<p>Example:</p>
<p><strong>A GROUP defined as a child of RESOURCE representing a singleton datatype instance </strong></p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;RESOURCE&gt;</span>
<span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source.SkyCoordinate<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;INFO</span><span class="ot"> value=</span><span class="st">&quot;The center coordinate of the simple cone search&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;ra&quot;</span><span class="ot"> value=</span><span class="st">&quot;123.00000&quot;</span> <span class="er">...</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;dec&quot;</span><span class="ot"> value=</span><span class="st">&quot;-2.10000&quot;</span> <span class="er">...</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;GROUP</span><span class="ot"> ref=</span><span class="st">&quot;_icrs&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:SkyCoordinate.frame<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
<span class="kw">&lt;/GROUP&gt;</span></code></pre></td></tr></table></div>
<p>Example:</p>
<p><strong>A GROUP defined as a child of a GROUP without annotation</strong></p>
<p>Note that the GROUP representing the singleton <strong>DataType</strong> is allowed to be contained in another GROUP, as long as that GROUP does not declare a VODML mapping. There are some restrictions. NONE of its ancestor GROUPs MAY be mapped to a data model element. This would conflict with rules of mapping such an ancestor GROUP that state that children of such GROUPs MUST be mapped to <strong>Roles</strong> of the structured type it represents. Whether the GROUP represents the <strong>DataType</strong> instance directly or indirectly is independent of this embedding in a parent GROUP. That is purely dependent on whether the GROUP has an ancestor TABLE or not.</p>
<p>An example of this pattern is the case of an assumed DAL protocol, say SCS that defines <em>implicitly</em> some data structure that has components that may be represented by elements from a data model as I the following example.</p>
<p>Example</p>
<p>A GROUP representing parameters of a Simple Cone Search with components mapped to data model elements.</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;RESOURCE&gt;</span>
<span class="kw">&lt;GROUP&gt;</span>
 <span class="kw">&lt;INFO</span><span class="ot"> value=</span><span class="st">&quot;The simple cone search request&quot;</span><span class="kw">/&gt;</span>
 <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;serchRadius&quot;</span><span class="ot"> value=</span><span class="st">&quot;3&quot;</span><span class="ot"> unit=</span><span class="st">&quot;arcsec&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
 <span class="kw">&lt;GROUP</span><span class="ot"> name=</span><span class="st">&quot;center&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source.SkyCoordinate<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;INFO</span><span class="ot"> value=</span><span class="st">&quot;The center coordinate of the simple cone search&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;ra&quot;</span><span class="ot"> value=</span><span class="st">&quot;123.00000&quot;</span> <span class="er">...</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;dec&quot;</span><span class="ot"> value=</span><span class="st">&quot;-2.10000&quot;</span> <span class="er">...</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;GROUP</span><span class="ot"> ref=</span><span class="st">&quot;_icrs&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:SkyCoordinate.frame<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
 <span class="kw">&lt;/GROUP&gt;</span></code></pre></td></tr></table></div>
<h3 id="root-datatype-values-in-table-records-indirect-group"><span class="header-section-number">6.3.2</span> Root DataType values in TABLE records: indirect GROUP</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP G | G <span class="math inline"> ⊂ </span> TABLE &amp; G <span class="math inline"> ⊄ </span> GROUP[VODML] &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>DataType</strong> &amp; G/VODML/ROLE = NULL}</td>
</tr>
</tbody>
</table>
<p>Restrictions:</p>
<ul>
<li>...</li>
</ul>
<p>Comments:</p>
<p>A GROUP defined on a TABLE, annotated with a <strong>DataType</strong>, represents a <strong>DataType</strong> instance indirectly.</p>
<p>Example</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;TABLE&gt;</span>
  <span class="kw">&lt;GROUP&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source.SkyCoordinate<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_ra&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>bSTC:SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_dec&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>bSTC:SkyCoordinate.latitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;GROUP</span><span class="ot"> ref=</span><span class="st">&quot;_icrs&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>bSTC:SkyCoordinate.frame<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/GROUP&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
...
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;ra&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_ra&quot;</span><span class="ot"> unit=</span><span class="st">&quot;deg&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;DESCRIPTION&gt;</span>right ascension (J2000 decimal deg)<span class="kw">&lt;/DESCRIPTION&gt;</span>
<span class="kw">&lt;/FIELD&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;dec&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_dec&quot;</span><span class="ot">  unit=</span><span class="st">&quot;deg&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;DESCRIPTION&gt;</span>declination (J2000 decimal deg)<span class="kw">&lt;/DESCRIPTION&gt;</span>
<span class="kw">&lt;/FIELD&gt;</span>
...</code></pre></td></tr></table></div>
<h3 id="datatype-as-attribute-group-in-group"><span class="header-section-number">6.3.3</span> DataType as Attribute: GROUP in GROUP</h3>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP A, GROUP G | A <span class="math inline"> ∈ </span> G &amp; A/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Attribute</strong> &amp; G/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong>}</td>
</tr>
</tbody>
</table>
<ul>
<li>A GROUP representing a structured type can have Attributes that are of a structured type as well.</li>
<li>However, this time the nested GROUP has a VODML/ROLE identifying the Attribute that the GROUP represents.</li>
</ul>
<p>Restrictions:</p>
<ul>
<li>The <strong>Attribute</strong> identified by GROUP A’s VODML/ROLE MUST be available to the structured type represented by the containing GROUP (G).</li>
<li>GROUP A SHOULD also declare the actual structured type it represents, through its VODML/TYPE. This type MUST be a valid type for the <strong>Attribute</strong>, i.e. the <strong>Attribute’s</strong> declared type or one of its subtypes. If the type in the serialization is a subtype, the VODML/TYPE MUST declare that.</li>
</ul>
<p><strong>Comments:</strong></p>
<p>Example</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source.Source<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
...
  <span class="kw">&lt;GROUP&gt;</span>
    <span class="kw">&lt;VODML&gt;</span>
      <span class="kw">&lt;ROLE&gt;</span>src:source.Source.position<span class="kw">&lt;/ROLE&gt;</span>
      <span class="kw">&lt;TYPE&gt;</span>src:source.SkyCoordinate<span class="kw">&lt;/TYPE&gt;</span>
    <span class="kw">&lt;/VODML&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_ra&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_dec&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.latitude<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;GROUP</span><span class="ot"> ref=</span><span class="st">&quot;_icrs&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.frame<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/GROUP&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
...
<span class="kw">&lt;/GROUP&gt;</span></code></pre></td></tr></table></div>
<h2 id="primitivetype-and-enumeration"><span class="header-section-number">6.4</span> PrimitiveType and Enumeration</h2>
<p><strong>PrimitiveTypes</strong> and <strong>Enumerations</strong> represent atomic values. They appear in serializations of data models predominantly in their role as attributes defined on structured types (<strong>ObjectType</strong> or <strong>DataType</strong>) and this specification focuses on that role. There is only limited extra information in identifying an individual FIELD or PARAM as representing some primitive type or enumeration from a data model, without indicating the role the FIELD or PARAM plays in some complex type. VO-DML assumes the existence of a standard data model (<strong>TODO</strong> <em>ivoa,</em> see [1] TBD refer to actual model) defining primitive types such as <em>ivoa:integer</em>, <em>ivoa:string</em> etc. But there is no new semantics implied by these types beyond the ones their counterparts in the VOTable schema carry<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>.</p>
<h3 id="singleton-primitive-value-as-param"><span class="header-section-number">6.4.1</span> Singleton primitive value as PARAM</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{PARAM P| P <span class="math inline"> ∉ </span> G[VODML] &amp; P/VODML/ROLE = NULL &amp; G/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>PrimitiveType</strong>|<strong>Enumeration</strong>}</td>
</tr>
</tbody>
</table>
<p>This indicates a PARAM that is <em>not</em> contained in a VODML-annotated GROUP, has a VODML/TYPE identifying an atomic type and no VODML/ROLE.</p>
<p><strong>TODO</strong> TBD do we want to support this? For if so, what about FIELDs?</p>
<h3 id="enumliteral-as-option"><span class="header-section-number">6.4.2</span> EnumLiteral as OPTION</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{FIELDref FR, FIELD F, OPTION O| <code>FR/@ref</code>=<code>F/@ID</code> &amp; O <span class="math inline"> ⊂ </span> F &amp; FR/VODML <span class="math inline"> ⇒ </span> Enumeration &amp; FR/VODML/OPTION/NAME = <code>O/@value</code> &amp; FR/VODML/OPTION/LITERAL <span class="math inline"> ⇒ </span> EnumLiteral}</td>
</tr>
</tbody>
</table>
<p><strong>TODO</strong></p>
<ul>
<li>VODML/OPTION</li>
<li>value to literal</li>
<li>value to SKOS concept</li>
</ul>
<h3 id="skosconcept-as-option"><span class="header-section-number">6.4.3</span> SKOSConcept as OPTION</h3>
<p><strong>TODO</strong></p>
<h2 id="attributes"><span class="header-section-number">6.5</span> Attributes</h2>
<h3 id="attribute-values-in-field-fieldref-in-group-in-table"><span class="header-section-number">6.5.1</span> Attribute values in FIELD: FIELDref in GROUP in TABLE</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{FIELDref F, GROUP G| F <span class="math inline"> ∈ </span> G &amp; G <span class="math inline"> ⊂ </span> TABLE &amp; F/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Attribute </strong> &amp; G/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong> }</td>
</tr>
</tbody>
</table>
<ul>
<li>A FIELDref contained in a GROUP represents an Attribute serialized by the FIELD it refers to.</li>
</ul>
<p>Restrictions</p>
<ul>
<li><p>The <strong>Attribute</strong> identified by the FIELDref/VODML/ROLE MUST be available to the structured type represented by the containing GROUP (G).</p></li>
<li><p>FIELDref MUST reference a FIELD in the TABLE that contains its parent GROUP.</p></li>
<li><p>The <strong>Attribute</strong> MUST have an atomic datatype, or a <strong>DataType</strong> from the set of special cases described in be section 7.9.</p></li>
<li><p>The <code>@datatype</code> of the referenced FIELD SHOULD be compatible with the declared <strong>datatype</strong> of the <strong>Attribute</strong>. E.g. an integer (<em>ivoa:integer</em>) <strong>Attribute</strong> SHOULD be represented by VOTable’s int or long.</p></li>
</ul>
<p>Example</p>
<p>See example in 6.2.</p>
<h3 id="attribute-to-param-in-group"><span class="header-section-number">6.5.2</span> Attribute to PARAM in GROUP</h3>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{PARAM P, GROUP G | P <span class="math inline"> ∈ </span> G &amp; G/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Attribute</strong> &amp; G/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType}</strong></td>
</tr>
</tbody>
</table>
<ul>
<li>When defined inside of a GROUP that represents a structured type, a PARAM MAY represent an Attribute of the type itself. The Attribute is declared by the <code>@utype</code>.</li>
</ul>
<p>Restrictions</p>
<ul>
<li>The <strong>Attribute</strong>’s <strong>datatype</strong> MUST identify an atomic type, i.e. a <strong>PrimitiveType</strong> or <strong>Enumeration</strong>, or a <strong>DataType</strong> from the set of special cases described in be section 7.9.</li>
<li>The PARAM <code>@datatype</code> SHOULD be a compatible, valid serialization type for the <strong>datatype</strong> of the <strong>Attribute</strong>.</li>
</ul>
<p>Example</p>
<p><strong>TODO</strong> See example in TBD</p>
<h3 id="attribute-to-paramref-in-group"><span class="header-section-number">6.5.3</span> Attribute to PARAMref in GROUP</h3>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{PARAMref P, GROUP G | P <span class="math inline"> ∈ </span> G &amp; P/VODML/ROLE <span class="math inline"> ⇒ </span> Attribute &amp; GROUP/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong>]</td>
</tr>
</tbody>
</table>
<p>Inside a GROUP a PARAMref identifies a PARAM defined inside the same RESOURCE or TABLE where the GROUP is defined. Using its VODML/ROLEthe PARAMref can annotate the PARAM as holding the value of an <strong>Attribute</strong>.</p>
<p>Restrictions</p>
<ul>
<li><p>The <strong>Attribute</strong> must be available to the structured type represented by the containing GROUP G.</p></li>
<li><p>The PARAM referencd by the PARAMref MUST obey the restrictions defined for the annotation of a PARAM by the <strong>Attribute’s</strong> type in section 7.5.2.</p></li>
</ul>
<p>Example</p>
<p>See example in 6.2</p>
<h3 id="datatype-as-attribute-groupref-in-group"><span class="header-section-number">6.5.4</span> DataType as Attribute: “GROUPref” in GROUP</h3>
<p>A PARAMref identifyin some PARAMin a GROUP can represent an <strong>Attribute</strong> with an atomic type on a <strong>StructuredType</strong>, so we can to a GROUP representing a structured <strong>DataType</strong> to represent <strong>Attributes</strong>.</p>
<h2 id="references"><span class="header-section-number">6.6</span> References</h2>
<p>A <strong>Reference</strong> is a relation between a structured type (the “referrer”, an <strong>ObjectType</strong> or <strong>DataType</strong>) and an <strong>ObjectType</strong>, the “target object”, or “referenced object”. The reference is a property defined on the referrer; it is one of the roles an <strong>ObjectType</strong> can play in the definition of another structured type. <strong>Reference</strong> is a many-to-1 relation, many referrers can reference the same target object. The implication of a Reference relation is that the referenced object is somehow “used” by the referrer. Often, especially when the referrer is a <strong>DataType</strong>, it defines reference data that helps interpret the values its attributes assume. See the VO-DML document [1] for more information.</p>
<p>In explicit serialization languages [TBD must define and discuss this term earlier in this document, say in section 3] such as XML Schema or the relational model there is support for representing this relation. E.g. XML schema allows one to define an attribute of type ID, which must have a value unique in the document. Another element can “refer” to this element using an attribute of type IDREF. It does so by assigning a value to the IDERF attribute and that same value MUST have been assigned to the ID attribute of another element for the document to be valid. This equality of values implies the relationship between the two elements, but there is in the definition no restriction on the type of the referenced element.</p>
<p>If a restriction on the referenced element is desired, XML Schema also allows one to define a “key/keyref” combination. A <em>key</em> has a unique name and is defined using an XPath [REF] “selector”, identifying a set of elements in a document and one or more fields that define the unique values distinguishing between these elements. A <em>keyref</em> can similarly be defined by the name of the target key, a selector identifying the referrer elements and the fields used for identifying the specific referenced elements among the ones defined by the key.</p>
<p>In a relational database a column on one table can be defined as a (primary) key, its values must be unique in that table<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>. Another table (or even the same one) can declare a column to be a “foreign key”, which “references” the first table through its key column.</p>
<p>In all three cases the reference relationship is implemented using pairs of elements which take up the same value, the ID or key, being referenced using the IDREF and keyref/foreign key column(s). These elements can be seen as addresses and pointers, the way by which similar relationships can be made in programming languages, sometimes explicit, as in C/C++, sometimes implicit as in Java/C#.</p>
<p>The mapping prescription laid out in this specification follows the same approach. It identifies three different patterns for representing references between instances of <strong>Types</strong>. Their difference lies in the way the target object is represented and identified, which puts demands on the way to identify them on the referrer objects. If the target object is serialized in the same document as the referrer it may be either represented as a singleton object represented by a direct Group (7.2.1) or as an object in a table (7.2.2 – 7.2.3).</p>
<p>The specification also allows for the case where the target object is <em>not</em> represented in the same VOTable document as the referrer. It may exist in another VOTable, or in some alternative, possibly standardized serialized form. An example of the latter could be an XML document following a standardized XML schema explicitly defined to represent the data model, or possibly a location in some publicly accessible database with a relational schema mapped to the model in a standardized Object-Relational manner.</p>
<p>This “remote reference pattern” is potentially very useful. By locating certain standard, reference data objects in some well-defined place, possibly a registry, different documents can reference the same instance in an explicit and interoperable manner. In this case, instead of providing a serialization of (part of) the referenced object with every file that uses it, a reference to the external serialization could be sufficient.</p>
<p>As an example consider defining a set of standard space-time coordinate reference frames and registering these in an IVOA sanctioned registry, with a well-defined and unique IVOA Identifier. Client tools could be coded to understand references to such standard data sets, so that their identifier might suffice to express the reference. Alternatively they might cache such globally persistent instances so to minimize de-referencing. Proper support for such standard reference data requires some standardized form for their registration and storage, an effort that should be part of the creation of standard data models and should have maintenance responsibilities similar to that of the UCD vocabulary [8].</p>
<p>In all patterns below the actual <strong>Reference</strong> is represented by a GROUP contained by the GROUP representing the referrer, and with structure that allows the identification of the target object. We do this for uniformity: there may be cases where a single reference PARAM for example might be sufficient, just as an IDREF can identify a target with an ID in XML Schema, but more generic cases require more structure. And in fact our solution for this simplest case, using what we will refer to as a “GROUPref” (including the quotes), is more lightweight even that a solution with a PARAM as will be shown next.</p>
<h3 id="reference-to-singleton-object-in-direct-group"><span class="header-section-number">6.6.1</span> Reference to singleton Object in direct GROUP</h3>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP S, GROUP R, GROUP T| S/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong> &amp; R <span class="math inline"> ∈ </span> S &amp; <code>R/@ref</code> = <code>T@ID</code> &amp; T/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; R/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Reference</strong> &amp; T <span class="math inline"> ∉ </span> TABLE &amp; T <span class="math inline"> ⊂ </span> RESOURCE [&amp; R/VODML/TYPE = <em>“vo-dml:GROUPref”</em>]}</td>
</tr>
</tbody>
</table>
<p>This pattern represents a source GROUP R (the <em>reference</em>), contained in a GROUP S (the <em>referrer</em>) representing a <strong>StructuredType</strong>, referencing a <em>target</em> GROUP T, representing a singleton <strong>ObjectType</strong> instance. The reference R uses its <code>@ref</code> attribute to identify the target GROUP T which is identified by a unique <code>@ID</code>. The GROUP R has no elements apart from the VODML element which MUST contain a ROLE identifying a particular <strong>reference</strong>; it MAY explicitly identify its VODML/TYPE as being <em>vo-dml:GROUPref</em>.</p>
<p>We refer to this pattern represented by GROUP R as a “GROUPref”, it is a reference to an identified GROUP. But we use the quotes as we do not need an explicit GROUPref element in the sense of VOTABLE’s FIELDref and PARAMref to represent this concept. It can also be used in other patterns as shown in the next section.</p>
<p>Restrictions</p>
<ul>
<li><p>The <strong>Reference</strong> identified by R/VODML/ROLE MUST be <em>available</em> on the <strong>StructuredType</strong> identified by O/VODML.</p></li>
<li><p><strong>OjectType</strong> identified by T/VODML MUST be compatible with the <strong>datatype</strong> of the <strong>Reference</strong>, i.e. must either be the same type or one of its subtypes.</p></li>
<li><p>The GROUP R representing the <strong>Reference</strong> must not have any child elements apart from the VODML element.</p></li>
</ul>
<p>Example</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;GROUP</span><span class="ot"> ID=</span><span class="st">&quot;_2massJ&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>phot:PhotometryFilter<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;name&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> value=</span><span class="st">&quot;2mass:J&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>phot:PhotometryFilter.name<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
...
<span class="kw">&lt;/GROUP&gt;</span>
...
<span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source/Source<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;GROUP&gt;</span>
    <span class="kw">&lt;VODML&gt;</span>
      <span class="kw">&lt;ROLE&gt;</span>src:source/Source.luminosity<span class="kw">&lt;/ROLE&gt;</span>
      <span class="kw">&lt;TYPE&gt;</span>src:source/LuminosityMeasurement<span class="kw">&lt;/TYPE&gt;</span>
    <span class="kw">&lt;/VODML&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_magJ&quot;</span> <span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.LuminosityMeasurement.value<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_errJ&quot;</span> <span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.LuminosityMeasurement.error<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;GROUP</span><span class="ot">  ref=</span><span class="st">&quot;_2massJ&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source/LuminosityMeasurement.filter<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
...</code></pre></td></tr></table></div>
<h3 id="reference-to-objects-in-a-table-i-objects-in-same-row"><span class="header-section-number">6.6.2</span> Reference to object(s) in a TABLE I: objects in same row</h3>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP S, GROUP R, GROUP T, TABLE TB| S/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong> &amp; R <span class="math inline"> ∈ </span> S &amp; <code>R/@ref</code> = <code>T@ID</code> &amp; TB/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; R/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Reference</strong> &amp; S <span class="math inline"> ⊂ </span> TB &amp; T <span class="math inline"> ⊂ </span> TB [&amp; R/VODML/TYPE = <em>“vo-dml:GROUPref”</em>] }</td>
</tr>
</tbody>
</table>
<p>This pattern represents a “reference GROUP” R, contained in “source GROUP” S representing a structured type, referencing a “target GROUP T”. Both S and T are contained in the same TABLE TB and a “GROUPref” is used to represent the reference.</p>
<p>This pattern indicates that each row in the TABLE TB contains (at least) two objects, represented by GROUPS S and T, and that S references T through the reference represented by GROUP R. R has no elements apart from the VODML element; it MUST identify the actual <strong>reference</strong> in its VODML/ROLE element; it SHOULD explicitly identify its VODML/TYPE as being v<em>o-dml:GROUPref</em>; it MUST identify which reference it represents through its VODML/ROLE.</p>
<p><strong>Example</strong>:</p>
<p>TBD</p>
<h3 id="reference-to-objects-in-a-table-ii-objects-in-different-rows-possibly-different-table"><span class="header-section-number">6.6.3</span> Reference to object(s) in a TABLE II: objects in different rows, possibly different TABLE</h3>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP S, GROUP R, GROUP T, GROUP PK, GROUP FK | S <span class="math inline"> ⊂ </span> TABLE &amp; T <span class="math inline"> ⊂ </span> TABLE &amp; S/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong> &amp; T/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; PK <span class="math inline"> ∈ </span> T &amp; PK/VODML/ROLE=<em>”vo-dml:ObjectTypeInstance.ID”</em> &amp; R <span class="math inline"> ∈ </span> S &amp; R/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>reference</strong> &amp; R/VODML/TYPE = <em>“vo-dml:ORMReference”</em> &amp; FK <span class="math inline"> ∈ </span> R &amp; FK/VODML/ROLE=<em>”vo-dml:ObjectTypeInstance.ID”</em> [&amp; <code>R/@ref</code> = <code>T@ID</code>] }</td>
</tr>
</tbody>
</table>
<p>This is the most complex pattern in this specification. It is the analogue of a foreign key constraint in a relational database. The pattern represents a “reference GROUP” R, contained in “source GROUP” S representing a structured type, referencing a “target GROUP T”. S and T may be contained in the same TABLE, but in general this need not be the case.</p>
<p>This pattern indicates that each row in the TABLE annotated by GROUP S contains a corresponding structured object, which has a reference to an object represented by GROUP T, located in some row in its TABLE. The reference is represented by the GROUP R. The GROUP R MUST identify which reference it represents through its VODML/ROLE. R MUST explicitly identify its VODML/TYPE as being <em>vo-dml:ORMReference</em>.</p>
<p>This latter requirement indicates that this pattern represents an object-relational mapping pattern. It is clear that in contrast to the previous two cases the combination of <code>S/@ref</code> and <code>T/@ID</code> is not sufficient to identify which objects are related. To make the connection this specification prescribes that the relation must be based on a kind of foreign key pattern.<br />
First, the objects T MUST be explicitly identified as described in 7.2.3. So T MUST contain a GROUP PK with VODML/ROLE=”<em>vo-dml:ObjectTypeInstance.ID</em>” and I must contain components which allow one to distinguish between different instances of type T in table T2. This may be a unique<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> identifier, but this is not mandatory.</p>
<p>To identify which T is referenced, the reference GROUP R MUST contain a “foreign key GROUP” FK that also has VODML/ROLE=”<em>vo-dml:ObjectTypeInstance.ID</em>”. It’s structure MUST be compatible with the structure of the GROUP PK. In general this means that if PK contains <em>N</em> FIELDrefs, also FK must contain <em>N</em> FIELDrefs. In general N=1, but if not, this specification prescribes that the order is important. I.e. FK’s FIELDref 1 must be matched to PKs FIELDref 1 etc. to find the referenced objects. Note also that it is allowed that FIELDref-s in PK are matched by PARAMs in FK. [TBD other way as well?]</p>
<p>Example:</p>
<p>TBD</p>
<h3 id="reference-to-object-in-external-data-store"><span class="header-section-number">6.6.4</span> Reference to Object in external data store</h3>
<p><strong>Pattern Expression</strong>:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP O, GROUP S, PARAM P| O/VODML <span class="math inline"> ⇒ </span> <strong>StructuredType</strong> &amp; S <span class="math inline"> ∈ </span> O &amp; <code>S/@ref</code> = NULL &amp; S/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Reference</strong> &amp; S/VODML/TYPE = <em>“vo-dml:RemoteReference”</em> &amp; P <span class="math inline"> ∈ </span> S &amp; (P/VODML/ROLE = “<em>vo-dml:RemoteReference.ivoid”</em> | P/VODML/ROLE = “<em>vo-dml:RemoteReference.uri”</em>) }</td>
</tr>
</tbody>
</table>
<p>This pattern identifies a reference to an object serialized elsewhere. Such an instance MUST be identified using an IVOA Identifier [12] if it is stored in an IVOA Registry. However, a URL might be provided as a convenient hook for the client. The reference is again represented by a GROUP, but now with PARAM whose <code>@value</code> is an IVOA Identifier. As alternative one can use a URI, but exactly <em>how</em> that should be resolved is outside of the scope of this document.</p>
<p><strong>Example:</strong></p>
<p>For example the previous example from the previous sub-section could be written as follows:</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;&lt;TYPE&gt;</span>src:source/Source<span class="kw">&lt;/TYPE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;GROUP&gt;</span>
    <span class="kw">&lt;VODML&gt;</span>
      <span class="kw">&lt;ROLE&gt;</span>src:source/Source.luminosity<span class="kw">&lt;/ROLE&gt;</span>
      <span class="kw">&lt;TYPE&gt;</span>src:source/LuminosityMeasurement<span class="kw">&lt;/TYPE&gt;</span>
    <span class="kw">&lt;/VODML&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_magJ&quot;</span> <span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.LuminosityMeasurement.value<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_errJ&quot;</span>  <span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.LuminosityMeasurement.error<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;GROUP</span> <span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;</span>
        <span class="kw">&lt;ROLE&gt;</span>src:source/LuminosityMeasurement.filter<span class="kw">&lt;/ROLE&gt;</span>
        <span class="kw">&lt;TYPE&gt;</span>vo-dml:RemoteReference<span class="kw">&lt;/TYPE&gt;</span>
      <span class="kw">&lt;/VODML&gt;</span>
      <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;ivoid&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span>
<span class="ot">             value=</span><span class="st">&quot;ivo://ivoa.registry/dm/phot/instances/2mass.J&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:RemoteReference.ivoid<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
      <span class="kw">&lt;/PARAM&gt;</span>
      <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;ivoid&quot;</span><span class="ot"> datatype=</span><span class="st">&quot;char&quot;</span><span class="ot"> arraysize=</span><span class="st">&quot;*&quot;</span>
<span class="ot">             value=</span><span class="st">&quot;http://ivoa.registry/dm/phot/instances/2mass#J&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:RemoteReference.uri<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
      <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
...</code></pre></td></tr></table></div>
<p>Here it is assumed that the DM working group maintains a set of data model instance documents for various instruments and stores these in some registry. [TBD check how realistic the ivoId is, add URL.]</p>
<h2 id="composition"><span class="header-section-number">6.7</span> Composition</h2>
<p>A <strong>Composition</strong> is defined in VO-DML as a “whole-parts” relation between parent and child <strong>ObjectTypes</strong>. The child can be interpreted as defining a <em>part</em> of the parent, the parent is “composed of” the child objects. Generally a parent can have a collection of 0..N children of a certain type, where N may be unbounded, but the multiplicity can be more constrained. The relation between the child and its parent is much stronger than the relation between a source and a target in a <strong>Reference</strong> relation. In particular the child’s life-cycle is tightly coupled to its parent: a child only has one parent and when when the parent is deleted, so is the child. Because of this also the serialization of the relationship may in many cases be more direct than the indirect reference mapping patterns of the previous section.</p>
<p>For example, in faithful XML serializations of a data model one will generally map child objects as elements directly contained by the parent element. It is possible to do so in VOTable as well, having a child object represented by a GROUP that is contained within the GROUP representing the parent. This pattern is the most natural for this relationship because a collection element is really to be considered as a <em>part</em> of the parent object.</p>
<p>This containment of GROUPs can be used for singleton patterns in an obvious manner. But it may also be used to represent a flattening of the parent-child relation in a TABLE. One or more child objects may be stored together with the parent object in the same row in a TABLE. Such a case is actually very common, for example when interpreting tables in typical source catalogues. These generally contain information of a source together with one or more magnitudes. The latter can be seen as elements from a collection of photometry points contained by the sources. (See the sample data model).</p>
<p>Faithful object-relational mapping of composition relations does generally not allow for such a containment. The typical pattern is that the table representing the child <strong>ObjectType</strong> has a foreign key to the table representing the parent. This specification allows for this mapping pattern as well, using the ORMReference pattern from section 7.6.3 in combination with the implicit <em>vo-dml:ObjectType.container</em> <strong>Reference</strong>.</p>
<h3 id="composition-i-child-group-inside-parent-group"><span class="header-section-number">6.7.1</span> Composition I: child GROUP inside parent GROUP</h3>
<p><strong>Pattern Expression</strong>:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP P, GROUP C | C <span class="math inline"> ∈ </span> P &amp; P/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; C/VODML/ROLE <span class="math inline"> ⇒ </span> <strong>Composition</strong> [&amp; C/VODML/TYPE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong>] }</td>
</tr>
</tbody>
</table>
<p>GROUP C represents a child object in a <strong>collection</strong> on some <strong>ObjectTupe</strong> identified by its VODML/ROLE, and of <strong>datatype</strong> possibly identified by its VODML/TYPE. In this pattern C is contained inside of a GROUP P that represents an <strong>ObjectType</strong> that is a valid <strong>Container</strong> of the <strong>Collection</strong>.</p>
<p>No statement is made about the location of the parent GROUP. If it is inside a RESOURCE, <em>not</em> in a TABLE, both parent and child represent singleton objects. If it is inside a TABLE, each row stores both parent and child objects.</p>
<p>Note also that there may be multiple child GROUPs identifying the same composition relation in the same parent GROUP.</p>
<p>Example</p>
<p>See example in 6.4</p>
<h3 id="composition-ii-object-relational-reference-from-child-to-parent-both-in-tables"><span class="header-section-number">6.7.2</span> Composition II: object-relational reference from child to parent, both in TABLEs</h3>
<p>Every instance of an <strong>ObjectType</strong> inherits from its implicit ultimate super type <em>vo-dml:ObjectTypeInstance</em> its <em>vo-dml:ObjectTypeInstance.container</em> property. In the <em>vo-dml</em> model this is represented as a collection of type <em>vo-dml:Reference</em>, with multiplicity 0..1. This should be interpreted as the possibility of adding on a serialized <strong>ObjectType</strong> instance a reference to its container/parent object.</p>
<p>In the case of serializing to a VOTable, this allows one to implement an object relational mapping pattern for the parent-child relation as described in the introduction to this section.</p>
<p>Pattern Expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP CH, GROUP R, GROUP P, GROUP PK, GROUP FK | CH <span class="math inline"> ⊂ </span> TABLE &amp; P <span class="math inline"> ⊂ </span> TABLE &amp; CH/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; P/VODML <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> &amp; PK <span class="math inline"> ∈ </span> P &amp; PK/VODML/ROLE=”<em>vo-dml:ObjectTypeInstance.ID</em>” &amp; R <span class="math inline"> ∈ </span> CH &amp; R/VODML/ROLE = “<em>vo-dml:ObjectTypeInstance.container</em>” &amp; R/VODML/TYPE = “<em>vo-dml:ORMReference</em>” &amp; FK <span class="math inline"> ∈ </span> R &amp; FK/VODML/ROLE=”<em>vo-dml:ObjectTypeInstance.ID</em>” [&amp; <code>CH/@ref</code> = <code>P@ID</code>] }</td>
</tr>
</tbody>
</table>
<p>The GROUP CH represents a collection of child objects that are contained in parent objects represented by GROUP P. CH and P are generally stored in different tables. CH references P following the ORM reference pattern described in section 7.6.3 above. The only constraint is that the VODML/ROLE on the GROUP representing the reference MUST be <em>vo-dml:ObjectTypeInstance.container</em>.</p>
<p>For clients it is useful if an identification is made <em>which</em> collection on the parent object the type represented by GROUP CH belongs to. The VO-DML spec restricts types to be the child in at most one composition relation, where inheritance/polymorphism is taken into account<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. Hence that information is in principle available through the VO-DML model and an explicit indication would be redundant, but it may make implementation of clients simpler.</p>
<p>One way to make this reference is to allow the GROUP CH to have a VODML/ROLE identifying the collection as well as the VODML/TYPE. An objection to this could be if we want to keep the invariant that only those GROUPs can have a VODML/ROLE that are contained inside another GROUP defining a type on which the role is available [TBD ref to statement along these lines in this spec, <em>if</em> we impose this rule]. The following pattern is a possible implementation that preserves this invariant:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP CH, GROUP R, PARAM P | P <span class="math inline"> ∈ </span> R &amp; P/VODML/ROLE = ”<em>vo-dml:ORReference.container</em>” &amp; <code>P/@value</code> <span class="math inline"> ⇒ </span> <strong>collection</strong> &amp; <code>P/@datatype</code> = ”string” [ &amp; P/VODML/TYPE = ”<em>vo-dml:ref</em>”] }</td>
</tr>
</tbody>
</table>
<p>The PARAM on the GROUP R identifies the collection, which MUST be available on the <strong>ObjectType</strong> represented by the GROUP P.</p>
<p>Annotators SHOULD add a reference from the parent group to the group representing the collection of child objects according to the following pattern:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{GROUP P, GROUP C, GROUP CH| C <span class="math inline"> ∈ </span> P &amp; C/VODML/ROLE = <strong>collection</strong> &amp; C/VODML/TYPE = “<em>vo-dml:CollectionReference</em>” &amp; <code>C/@ref</code> = <code>CH@ID</code> }</td>
</tr>
</tbody>
</table>
<p>It indicates that the GROUP representing the container P contains a GROUP C representing a “collection reference” to the GROUP with the child objects C. It does <em>not</em> indicate that all objects in C are contained in P. And the child objects MUST have the container reference as defined in the first pattern above.</p>
<p>TBD Do we want these extra patterns? They imply a redundancy with the first. That one is sufficient to define the relation and necessary as it defines how to identify the parent on the child. The third pattern does allow parsers to start looking for the children as soon as the collection-reference is encountered.</p>
<p><strong>TODO</strong> should we merge these patterns into one? Would make the pattern even more complex.</p>
<p><strong>Example</strong>:</p>
<p>TBD</p>
<h2 id="extends-inheritance-todo-needs-work"><span class="header-section-number">6.8</span> Extends, inheritance (<strong>TODO</strong> needs work!)</h2>
<p>The inheritance relation between two <strong>Type</strong>-s might seem not to be relevant for serializations and mapping. After all the relation implies no relation between objects, the target of serializations, only between types. In serializations, any inherited <strong>Role</strong> can appear on a sub-type and, as described above, all properties inherited from a super-type are identified with the <em>vodml-id</em> defined on the super-type.</p>
<p>There are some special cases though where inheritance makes a non-trivial appearance. The first we have seen already, in that we can explicitly <em>cast</em> a <strong>Role’s</strong> value to a sub-type of a declared datatype. Supporting this type of polymorphism at the serialization level is one main motivation for adding <code>&lt;TYPE&gt;</code> to the <code>&lt;VODML&gt;</code> element. See Appendix B for a discussion how different types of clients can deal with this.</p>
<p>There are however subtler issues related to inheritance mapping. An example comes from a typical object-relational mapping pattern for inheritance hierarchies. When creating a relational model for an object model with inheritance hierarchies, usually there are three patterns people will follow.</p>
<p>One may choose to map each concrete (i.e. non-abstract) type to its own table. But one may also choose to map all sup-types of a given (ultimate) super type to a single table. Different rows may store different sub-types, and certain columns defined for storing an attribute defined on one sub-type will in general be NULL on its siblings. Or one may choose a mixture of these where there is a table for each type, but these only store elements defined on that type; sub-types have a foreign key to their parent and to retrieve a complete subtype this pointer must be followed, possibly recursively until the ultimate super-type. Tools such as Hibernate [7] provide explicit support for these inheritance mapping patterns, and we point the reader to their documentation for more information.</p>
<p>In the latter two patterns there will generally be a table, either the single one storing the whole hierarchy, or the one representing the ultimate super-type, which defines a special column that allows one to decide which concrete sub-type is stored in a particular row. This may be through some pre-agreed code, or by storing the complete name of the type.</p>
<p>This pattern can be supported as well.</p>
<p>Pattern Expression:</p>
<p>(<strong>TODO</strong> Pattern missing?)</p>
<p>In this case the <span class="math inline"> ⇑ </span> symbol means that the leftmost ObjectType <em>extends</em> the rightmost ObjectType, adding some Attributes to it. Attributes can be structured or unstructured, direct or indirect, recursively. This mapping pattern leverages the patterns introduced in the previous sections.</p>
<p>The extending type inherits all of the parent type’s Attributes and their VO-DML-refs (including the prefixes), and adds its own Attributes and their VO-DML-refs (including the prefixes).</p>
<p>The extending type also inherits all of the parent’s ancestors, recursively. Thus, the serialization of the child type MUST include all the ancestors’ declarations of <em>vo-dml:Instance.type</em>. This makes it possible for clients of any ancestor to recognize the instance and to correctly apply polymorphism.</p>
<p>It is possible that types in a Model extend types in the same Model. In this case one can already tell them apart from the a priori knowledge of a Model, or by parsing the VO-DML description of the Model, and <strong>vodml-id</strong>-s cannot clash by definition. So, the pattern described above, where the child representation carries over the vo-dml:Instance.type from its ancestors only applies to inter-Model extensions, UNLESS the extended type is abstract. In this case, clients may want to look for the abstract type before interpreting the actual concrete type. For instance, a client may look for all the “<em>src:source.SkyError</em>” instances before interpreting them as a circle error, an elliple error, and so on.</p>
<p>For example, assuming that the ExtentedSource Model extends the Source Model (Attribute source.Source.redshift), and that the ExtendedExtendedSource Model extends the ExtendedSource Model (Attribute source.Source.profile), a serialization will look like this:</p>
<p><strong>Example</strong></p>
<div class="sourceCode" hl_lines="1 2"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;TABLE&gt;</span>
<span class="kw">&lt;GROUP&gt;</span>
  <span class="kw">&lt;VODML&gt;</span>
    <span class="kw">&lt;TYPE&gt;</span>xxsrc:Source<span class="kw">&lt;/TYPE&gt;</span>
    <span class="kw">&lt;TYPE&gt;</span>xsrc:Source<span class="kw">&lt;/TYPE&gt;</span>
    <span class="kw">&lt;TYPE&gt;</span>src:source.Source<span class="kw">&lt;/TYPE&gt;</span>
  <span class="kw">&lt;/VODML&gt;</span>
  <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_designation&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>vo-dml:ObjectTypeInstance.ID<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/FIELDref&gt;</span>
  <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_designation&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.Source.name<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/FIELDref&gt;</span>
  <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_z&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>xsrc:source.Source.redshift<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/FIELDref&gt;</span>
  <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_profile&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>xxsrc:source.Source.profile<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/FIELDref&gt;</span>
  <span class="kw">&lt;PARAM</span><span class="ot"> name=</span><span class="st">&quot;type&quot;</span><span class="ot"> value=</span><span class="st">&quot;galaxy&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.Source.classification<span class="kw">&lt;/ROLE&gt;&lt;/VODML&gt;</span>
  <span class="kw">&lt;/PARAM&gt;</span>
  <span class="kw">&lt;GROUP&gt;</span>
    <span class="kw">&lt;VODML&gt;</span>
      <span class="kw">&lt;TYPE&gt;</span>src:source.SkyCoordinate<span class="kw">&lt;/TYPE&gt;</span>
      <span class="kw">&lt;ROLE&gt;</span>src:source.Source.position<span class="kw">&lt;/ROLE&gt;</span>
    <span class="kw">&lt;/VODML&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_ra&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.longitude<span class="kw">&lt;/ROLE&gt;&lt;/VODMLL&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;FIELDref</span><span class="ot"> ref=</span><span class="st">&quot;_dec&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.latitude<span class="kw">&lt;/ROLE&gt;&lt;/VODMLL&gt;</span>
    <span class="kw">&lt;/FIELDref&gt;</span>
    <span class="kw">&lt;GROUP</span><span class="ot"> ref=</span><span class="st">&quot;_icrs&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;VODML&gt;&lt;ROLE&gt;</span>src:source.SkyCoordinate.frame<span class="kw">&lt;/ROLE&gt;&lt;/VODMLL&gt;</span>
    <span class="kw">&lt;/GROUP&gt;</span>
  <span class="kw">&lt;/GROUP&gt;</span>
<span class="kw">&lt;/GROUP&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;designation&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_designation&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;ra&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_ra&quot;</span><span class="ot"> unit=</span><span class="st">&quot;deg&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;dec&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_dec&quot;</span><span class="ot">  unit=</span><span class="st">&quot;deg&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;z&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_z&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
<span class="kw">&lt;FIELD</span><span class="ot"> name=</span><span class="st">&quot;profile&quot;</span><span class="ot"> ID=</span><span class="st">&quot;_profile&quot;</span> <span class="er">...</span><span class="kw">/&gt;</span>
<span class="kw">&lt;TR&gt;&lt;TD&gt;</span>08120809-0206132<span class="kw">&lt;/TD&gt;&lt;TD&gt;</span>123.033734<span class="kw">&lt;/TD&gt;&lt;TD&gt;</span>-2.103671<span class="kw">&lt;/TD&gt;&lt;TD&gt;</span>0.123<span class="kw">&lt;/TD&gt;&lt;TD&gt;</span>devaucoulers<span class="kw">&lt;/TD&gt;&lt;/TR&gt;</span>
...
<span class="kw">&lt;/TABLE&gt;</span></code></pre></td></tr></table></div>
<p>In this example we have assumed that the VO-DML preamble declared the xsrc prefix for the ExtendedSource Model and the xxsrc prefix for the ExtendedExtendedSource Model.</p>
<h2 id="value-unit-ucd"><span class="header-section-number">6.9</span> Value, Unit, UCD</h2>
<p>Some DataTypes may have attribute names that can be naturally mapped to the VOTable PARAM and FIELD attributes. In this case, the following rules apply:</p>
<ul>
<li>the value of the DataType's 'value' attribute is stored in the <code>@value</code> attribute of the PARAM, or the TD corresponding to the annotated FIELD.</li>
<li>the value of the DataType’s 'unit' attribute is represented by the <code>@unit</code> attribute of the PARAM, or the annotated FIELD.</li>
<li>the value of the 'ucd' attribute is mapped to the <code>@ucd</code> attribute of the annotated FIELD or PARAM</li>
</ul>
<p>(<strong>TODO</strong> Extend this pattern to datatype, arraysize? ivoa:Quantity DM.)</p>
<h1 id="notable-absences"><span class="header-section-number">7</span> Notable absences</h1>
<p>The VOTable schema allows for redundancy in meta-data assignment. For example it allows assigning a UCD or UTYPE to FIELDrefs, but also to the FIELD it references. How is one to interpret or use this? Our approach is to try to avoid this redundancy.</p>
<p>The design laid out in the previous sections focuses UTYPE assignments on the GROUP element and its components. The main reason is that in all but the most simplistic use cases we will not be able to void the use of GROUPs, and that at the same time they provide all functionality (and more) that TABLE and FIELD could provide. Choosing this approach implies client coders do not need to take the possibly conflicting assignments into account, they only need consider GROUPs.</p>
<p>Here we list a few possible assignments that we avoid, though they might seem valid.</p>
<h2 id="atomic-types-support-for-custom-and-legacy-utypes"><span class="header-section-number">7.1</span> Atomic Types: support for custom and legacy UTYPEs</h2>
<p>It is worth stressing explicitly that some VOTable elements are not covered by this specification (e.g. TABLE, RESOURCE, INFO, FIELD, and standalone PARAM). Also, according to this specification some elements will be ignored in the de-serialization of DM instances if their UTYPEs do not have a prefix declared in the VO-DML preamble.</p>
<p>This is intentional, and its purpose is to achieve full backward compatibility of this standard with the current non-standardized usages, while enabling new, complex Data Models to be effectively serialized in a standardized way.</p>
<p>Atomic Types are types referenced by <code>@utype</code> attributes of FIELDs and standalone PARAMs (i.e. PARAMs not included in GROUPs). Usually these UTYPEs are path-like strings pointing to some implicit and unspecified meta-model in an atomic fashion. Such UTYPEs can happily coexist with UTYPEs used according to this specification.</p>
<p>Not only this means that this standard does not break any of the existing standards. Not only this means that it enables customized use of the <code>@utype</code> attribute in local implementations. This also means that in order to make a legacy VOTable file compliant with the new specs, Data Providers will only need, if willing to do so, to add some GROUP definitions to its header. Old clients of that file will still be able to parse them, while new generation clients will be able to perform their more advanced usage of the new specification.</p>
<h2 id="packages"><span class="header-section-number">7.2</span> Packages</h2>
<p>No use cases require the serialization of Package instances in VOTable. Package names are encoded in the UTYPE syntax of VO-DML for avoiding name clashes when two classes in different packages of the same model have the same name (other than that, UTYPEs are effectively opawue). The use of ‘.’ as the separator for the Package-&gt;Type relationship (e.g. source.Source) might cause name clashes when a package contains a Type and a Package with the same name. However, packages cannot be directly referenced by UTYPEs, so this is not an issue.</p>
<h2 id="objecttype-to-table"><span class="header-section-number">7.3</span> ObjectType to TABLE</h2>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">{ TABLE <span class="math inline"> ⇒ </span> <strong>ObjectType</strong> }</td>
</tr>
</tbody>
</table>
<p>There might be some cases where a TABLE could be said to represent a structured type completely, and where the TABLE could be annotated with a <code>&lt;VODML&gt;</code> element to indicate this. However in probably most cases only part of the TABLE will correspond to the type, or it will contain instances of multiple types stored inside a single row (e.g. photometry catalogs).</p>
<p>In all of these cases one can (and MUST) use one or more GROUP elements contained by the TABLE to make the precise assignment. Hence we extend this to the rare case where the TABLE might have been annotated to simplify the spec. By leaving this mapping pattern out we do not lose any information content. Also, this way client code only has to deal with GROUPs, with no need to inspect the TABLE.</p>
<h2 id="attribute-to-fieldparam-in-table"><span class="header-section-number">7.4</span> Attribute to FIELD|PARAM in TABLE</h2>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">[Field <span class="math inline"> ⇒ </span> Attribute] <span class="math inline"> ∈ </span> [TABLE <span class="math inline"> ⇒ </span> ObjectType]</td>
</tr>
</tbody>
</table>
<p>Pattern expression:</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">[PARAM <span class="math inline"> ⇒ </span> Attribute] <span class="math inline"> ∈ </span> [TABLE <span class="math inline"> ⇒ </span> ObjectType]</td>
</tr>
</tbody>
</table>
<p>Assigning an Attribute to a FIELD would only make sense in the context of a structured container, which can only be TABLE. But as we propose not to use TABLE to represent a DM element directly, consequently FIELD need not have this capability. We use FIELDref for that.</p>
<p>For the same reason that makes us avoid the assignment of Attribute to FIELD, we avoid assigning an attribute to a standalone PARAM, i.e. a PARAM <em>that is directly contained in a TABLE or RESOURCE</em>. The context (TABLE) is not used to indicate the type containing the Attribute. For this element a PARAMref or a PARAM inside a GROUP is to be used. This again enables backward compatibility.</p>
<h1 id="serializing-to-other-file-formats"><span class="header-section-number">8</span> Serializing to other file formats</h1>
<p>VOTable is expressive enough to allow the mapping patterns described in this specification. Other formats (notably FITS) cannot support such annotations. In particular FITS does not support the GROUP-ing of columns, which is of prime importance for the current specification. A solution to this, which is even one of the motivations behind the VOTable specification, is to annotate other format’s tables with a VOTable <em>wrapper</em>. VOTable (see [2], section 5.2) already supports wrapping FITS tables using a TABLE/DATA/FITS. This has a <code>STREAM/@href</code> URL to specify which FITS file is represented and an <code>@extnum</code> attribute to indicate which FITS extension is used.</p>
<p>Some FITS formats also allow a VOTable header to be included in an HDU. Whilst this would allow data and meta-data to be combined in a single file, this solution seems to be less portable, since some FITS readers do not support these files.</p>
<p>A similar solution could be used to annotate the tables in the schema of a TAP service. Here no specific support yet exists, but could be easily added to the TAP specification. I fact a VOTable representing all TAP tables as “empty” TABLE elements with only header, no DATA information has been proposed in the past as one of the ways by which a TAP schema’s metadata could be declared. If this were to be a formalized option it would automatically allow the mapping patterns from the current specification to be included. The main challenge for TAP is whether that annotation can be carried over to the results of queries against its schema. For the simple, column-only annotations such as UCDs or descriptions, this is already a non-trivial task, and not always possible<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a>. General ADQL queries can easily unravel the GROUP-ing of columns and their nesting and produce results that cannot be annotated with concepts of the original data models. However we believe this is a 90-10 problem, and for the most common queries it should be possible to identify the data model concepts with not much more work than is already required to carry along the UCDs.</p>
<p>This should in particular not be a problem for the results of standard protocols such as the simple cone search. There the service provider is in charge of designing the result set, which, being tabular, can be easily annotated using the current specification. In fact, in the absence of a TAP_SCHEMA-like mechanism, it could be argued that the current specification presents a perfect mechanism by which an SCS service can declare the contents of its holdings.</p>
<p>Whereas similar approaches can likely be used for other tabular formats, an interesting question is whether mapping patterns can be defined also for annotating serialization formats other than tables. In particular the more structured formats such as XML or JSON, or more modern ones such as Google Protocol Buffers<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> or Apache Avro<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a>, would pose different problems.</p>
<p>The first approach would be to see if and how such formats can be used to provide <em>faithful</em> representations as defined in section 3. For XML it has been shown in a similar effort (see [3] and [13]) that one can derive an XML schema that represents the types and relations of a well-defined data model in a 1-1 fashion. It is even possible to do so in an automated manner using code generation and we believe it would be a useful effort to define such . As long as a well-defined meta-model exists for the target serialization, and as long as it is rich enough we believe this will carry over to other serialization formats.</p>
<p>The problem is when one want to annotate existing XML documents that have not been designed as such. It has as yet not been explore whether a simple annotation mechanism such as the current one will work there as well. We believe that <em>if</em> the concepts of a data model can be identified in an informal manner, it may be possible to at least partially reproduce the target serialization as a <em>view</em> on a faithful serialization. For example one might define an XSLT document that, when working on a faithfully serialized data model would produce the desired one.</p>
<p>More useful would likely be the opposite, i.e. a document that would produce a faithful serialization of a non-faithful one. Such a document would allow clients to first transform the document to a known serialization for further processing. This brings one close to the global-as-view approach, in that the global schema, the data model, is represented as a view on the source.</p>
<p>More discussion will be needed to address these issues.</p>
<div class="references">
<div id="ref-usages">
<p>Graham, Matthew. 2013. “UTypes: Current Usages and Practices in the IVOA.” <a href="http://www.ivoa.net/documents/Notes/UTypesUsage/index.html" class="uri">http://www.ivoa.net/documents/Notes/UTypesUsage/index.html</a>.</p>
</div>
<div id="ref-vodml">
<p>Lemson, Gerard. 2015. “VO - DML: A Consistent Modeling Language for IVOA Data Models.” <a href="http://www.ivoa.net/documents/VODML/20151010/index.html" class="uri">http://www.ivoa.net/documents/VODML/20151010/index.html</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This used to be the assumed role of the <code>@utype</code> attribute in VOTable and for example TAP. This document introduces the new <code>&lt;VODML&gt;</code> element for this purpose in VOTable, as agreed on in interop meeting in Banff, 2014.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>See the Current Usages Note:</p>
<p>http://www.ivoa.net/documents/Notes/UTypesUsage/20130213/NOTE-utypes-usage-1.0-20130213.pdf<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>See, for example, http://logic.stanford.edu/dataintegration/chapters/chap01.html<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Or alternatively as a transformation of a (standard) serialization of the data model.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>This was foreseen for example in the note on referencing STC in VOTable <span class="citation">(<span class="citeproc-not-found" data-reference-id="stc_in_vot"><strong>???</strong></span>)</span>, as well as in a presentation by S. Derriere in Naples:</p>
<p>(<a href="../customXml/item1.xml">http://wiki.ivoa.net/internal/IVOA/InterOpMay2011SED/PPDMDesc_Naples.pdf</a>).<br />
Lacking a formal target modelling language these developments remained ad hoc.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>During various interoperability meetings, finalized in Banff 2014.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>See older versions of this document on volute, mentioned in the history above.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>If a model is registered in an IVOA compliant registry, its IVOID may be used instead of the URL to identify it. (<strong>TODO</strong> This will require a Registry extension and should be handled by VO-DML spec).<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Note that this model does <strong>not yet</strong> obey all of the data modelling rules imposed on real data models. It is defined to keep up the invariant that each vodmlref MUST refer to an element in a formal VO-DML/XML element.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Specifically:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> top <span class="dv">10</span> p.objID, p.run, p.rerun, p.camcol, p.field, p.obj,
p.type, p.ra, p.dec, p.u,p.g,p.r,p.i,p.z,
p.Err\_u, p.Err\_g, p.Err\_r,p.Err\_i,p.Err\_z
<span class="kw">FROM</span> fGetNearbyObjEq(<span class="dv">195</span>,<span class="fl">2.5</span>,<span class="dv">3</span>) n, PhotoPrimary p
<span class="kw">WHERE</span> n.objID=p.objID</code></pre></div>
<a href="#fnref10">↩</a></li>
<li id="fn11"><p>E.g. when interpreting a GROUP as a certain ObjectType, if one of its children is not annotated or identifies a child element that is not available on the type, this is an error. Fr each pattern there is a set of rules that, if broken, are annotation errors. (<strong>TODO</strong> we better strive to make these comprehensive.)<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p><em>ivoa</em> types that do not exist in VOTable may there be represented using appropriate xtypes, e.g. adql:timestamp for <em>ivoa:datetime.</em><a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>One can use multiple columns, that together must be unique (and NOT NULL!).<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>As discussed earlier, it is allowed that the same object is represented multiple times in the same table.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>I.e. if a super-type is declared as the child in a composition relation, this “property” is inherited by its sub-types.<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>E.g. consider SELECT a-b FROM foo. Even if columns a and b have a UCD, what is the UCD of their difference?<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>https://developers.google.com/protocol-buffers/<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>https://avro.apache.org/<a href="#fnref18">↩</a></p></li>
</ol>
</div>
</body>
</html>
